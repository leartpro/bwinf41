%! Author = leartpro
%! Date = 04.01.23

\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 1: Weniger krumme Touren} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeilnahmeId}{67275}                        % Teilnahme-ID angeben
\newcommand{\Name}{Lennart Protte}                      % Name des Bearbeiter / der Bearbeiterin dieser Aufgabe angeben


% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Teilnahme-ID: \TeilnahmeId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

%Für Überschriften
\usepackage[labelformat=empty]{caption}
\captionsetup[algorithm]{labelformat=empty}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{adigraph}
\usepackage{algorithm}
\usepackage{algorithmicx}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
    keywordstyle=\color{blue},commentstyle=\color{mygreen},
    stringstyle=\color{mymauve},rulecolor=\color{black},
    basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
    captionpos=b, % sets the caption-position to bottom
    keepspaces=true, % keeps spaces in text
    numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
    showtabs=false, stepnumber=2, tabsize=2, title=\lstname ,
    inputencoding = utf8,  % Input encoding
    extendedchars = true,  % Extended ASCII
    literate      =        % Support additional characters
        {á}{{\'a}}1  {é}{{\'e}}1  {í}{{\'i}}1 {ó}{{\'o}}1  {ú}{{\'u}}1
        {Á}{{\'A}}1  {É}{{\'E}}1  {Í}{{\'I}}1 {Ó}{{\'O}}1  {Ú}{{\'U}}1
        {à}{{\`a}}1  {è}{{\`e}}1  {ì}{{\`i}}1 {ò}{{\`o}}1  {ù}{{\`u}}1
        {À}{{\`A}}1  {È}{{\'E}}1  {Ì}{{\`I}}1 {Ò}{{\`O}}1  {Ù}{{\`U}}1
        {ä}{{\"a}}1  {ë}{{\"e}}1  {ï}{{\"i}}1 {ö}{{\"o}}1  {ü}{{\"u}}1
        {Ä}{{\"A}}1  {Ë}{{\"E}}1  {Ï}{{\"I}}1 {Ö}{{\"O}}1  {Ü}{{\"U}}1
        {â}{{\^a}}1  {ê}{{\^e}}1  {î}{{\^i}}1 {ô}{{\^o}}1  {û}{{\^u}}1
        {Â}{{\^A}}1  {Ê}{{\^E}}1  {Î}{{\^I}}1 {Ô}{{\^O}}1  {Û}{{\^U}}1
        {œ}{{\oe}}1  {Œ}{{\OE}}1  {æ}{{\ae}}1 {Æ}{{\AE}}1  {ß}{{\ss}}1
        {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1  {Ø}{{\O}}1   {å}{{\r a}}1
        {Å}{{\r A}}1 {ã}{{\~a}}1  {õ}{{\~o}}1 {Ã}{{\~A}}1  {Õ}{{\~O}}1
        {ñ}{{\~n}}1  {Ñ}{{\~N}}1  {¿}{{?`}}1  {¡}{{!`}}1
        {°}{{\textdegree}}1 {º}{{\textordmasculine}}1 {ª}{{\textordfeminine}}1
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}
\usepackage{tikz}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Teilnahme-ID: \LARGE \TeilnahmeId \\\\
\LARGE Bearbeiter/-in dieser Aufgabe: \\
\LARGE \Name\\\\}
\date{\LARGE\today}

\begin{document}

    \maketitle
    \tableofcontents
    \vspace{0.5cm}
    \newpage


    \section{Lösungsidee}\label{sec:losungsidee}

    Die vorliegende Aufgabe erfordert die Ermittlung einer beliebigen zulässigen Reihenfolge,
    in der Anton seine Außenstellen abfliegen kann,
    ohne dass es zu einem Innenwinkel von mehr als 90 Grad beim Abbiegen kommt.
    Es ist dabei zu beachten, dass keine Außenstelle ausgelassen werden darf
    und dass eine Außenstelle nicht mehrfach besucht werden darf.
    Da in dieser Aufgabe nicht die kürzeste Route gesucht wird, kann eine approximierte Lösung angestrebt werden.

    Die Problemstellung dieser Aufgabe lässt sich mit dem bekannten Handlungsreisendenproblem assoziieren,
    bei dem es darum geht, einen möglichst kurzen Hamiltonkreis in einem gewichteten Graphen zu finden.
    Allerdings verlangt die vorliegende Aufgabe nicht, dass der Start- und Endpunkt identisch sind,
    so dass es ausreichend ist, einen möglichst kurzen Hamiltonweg zu ermitteln.
    Das Hamiltonwegproblem ist NP-vollständig, so dass kein Algorithmus existiert,
    der die gegebene Aufgabe deterministisch in Polynomialzeit lösen kann.

    Zur Lösung des Problems kann ein Greedy-Algorithmus eingesetzt werden,
    der die Nearest-Neighbour-Heuristik und Backtracking verwendet.
    Bei der Auswahl des nächsten Außenpostens muss zusätzlich das Winkelkriterium beachtet werden.
    Alternative Ansätze, welche hier nicht tiefergehend betrachtet werden, wären Algorithmen für konvexe Hüllen,
    da als Eingabe eine endliche ungeordnete Menge an Punkten gegeben ist, welche alle auf einer Ebene liegen.
    Dieser Ansatz ist allerdings wahrscheinlich weniger für das Hamiltonpfadproblem,
    als vielmehr für das Problem des Handlungsreisenden geeignet.
    Des Weiteren stellt auch die Implementation eines solchen Algorithmus eine höhere Schwierigkeit dar.
    Eine weitere Alternative, wäre ein SAT-Solver.
    Dieser könnte durch alle Permutationen der gegebenen Punktmenge iterieren
    und jede Permutation auf ihre Erfüllbarkeit prüfen.
    Aber Aufgrund der Tatsache, dass es für $n$ Elemente $n!$ Permutationen gibt,
    könnte die Laufzeit entsprechend hoch ausfallen.

    Ein Greedy-Algorithmus, welcher einen Hamiltonpfad in einem euklidischen Graphen ermitteln kann,
    kann so lange Elemente zur Lösungsmenge hinzufügen, bis entweder alle Elemente in der Lösungsmenge sind,
    oder kein Element gibt, welches nach den Winkelkriterien als Nachfolger in Frage kommt.
    In diesem Fall greift das Backtracking und der letzte Schritt wird Rückgängig gemacht.

    \begin{algorithm}[H]
        \caption{Finde einen Hamiltonpfad in einem euklidischen Graphen}
        \begin{algorithmic}
            \Require Eine Menge von $n$ Punkten in der Ebene $P={(x,y)| x,y \in \mathbb{R}}$, dargestellt als Vektor von Paaren $\textit{koordinaten}=[(x_1,y_1), (x_2,y_2),\dots, (x_n,y_n)]$.
            \Ensure Ein Hamiltonpfad im Graphen, der alle Punkte in $\textit{koordinaten}$ verbindet, oder $\textit{falsch}$, falls ein solcher Pfad nicht existiert.
            \Function{HamiltonianPfad}{$\textit{route},\ \textit{koordinaten}$}
                \If {$\textit{route}$ ist nicht leer}
                    \State $p\gets \textit{letztes Element von } \textit{route}$
                    \State $\textit{sortiere } \textit{koordinaten } \textit{nach nicht abnehmender euklidischer Entfernung zu } p$
                \EndIf
                \For{$i=1$ bis $n$}
                    \If {$\textit{koordinaten}[i]$ ist bereits in $\textit{route}$}
                        \State $\textbf{continue}$
                    \EndIf
                    \State $\textit{winkel}\gets -1$
                    \If {$\textit{route}$ hat mindestens zwei Elemente}
                        \State $\textit{winkel}\gets$ \textsc{Schnittwinkel}$(\textit{route}[|\textit{route}|-1], \textit{route}[|\textit{route}|], \textit{koordinaten}[i])$
                    \EndIf
                    \If {$\textit{route}$ ist leer \textbf{oder} ($\textit{koordinaten}[i]$ ist nicht in $\textit{route}$ \textbf{und} ($|\textit{route}|<2$ \textbf{oder} $\textit{winkel} \geq 90$))}
                        \State $\textit{füge }\textit{koordinaten}[i]\textit{ zu route hinzu}$
                        \If {$|\textit{route}|=n$}
                            \State \textbf{return} \textit{wahr}
                        \EndIf
                        \If {\textsc{HamiltonianPfad}$(\textit{route},\ \textit{koordinaten})$}
                            \State \textbf{return} \textit{wahr}
                        \Else
                            \State $\textit{entferne das letzte Element aus route}$
                        \EndIf
                    \EndIf
                \EndFor
                \State \textbf{return} \textit{falsch}
            \EndFunction
        \end{algorithmic}\label{alg:pseudo_greedy}
    \end{algorithm}

    Der Winkel zwischen zwei Kanten kann dabei über den Kosinussatz ermittelt werden.
    Dazu wird ein Dreieck aus dem vorletzte Punkt der Lösungsmenge, dem letzten Punkt der Lösungsmenge
    und dem aktuellen Punkt gebildet.

    \begin{algorithm}[H]
        \caption{Berechnet den Winkel zwischen zwei Kanten}
        \begin{algorithmic}
            \Function{Schnittwinkel}{$von_{knoten},\ddot uber_{knoten},zu_{knoten}$}
                \State $\textit{a}\gets \sqrt{(von_{knoten.x} - zu_{knoten.x})^2 + (von_{knoten.y} - zu_{knoten.y})^2}$
                \State $\textit{b}\gets \sqrt{(von_{knoten.x} - \ddot uber_{knoten.x})^2 + (von_{knoten.y} - \ddot uber_{knoten.y})^2}$
                \State $\textit{c}\gets \sqrt{(\ddot uber_{knoten.x} - zu_{knoten.x})^2 + (\ddot uber_{knoten.y} - zu_{knoten.y})^2}$
                \State $\textit{winkel} \gets \arccos\left(\frac{a^2 - b^2 - c^2}{-2bc}\right) \times \frac{180}{\pi}$
                \State \Return $winkel$
            \EndFunction
        \end{algorithmic}\label{alg:pseudo_crossangle}
    \end{algorithm}

    Die grundlegende Konzeption des Algorithmus besteht darin, eine geeignete Reihenfolge der Punkte zu ermitteln,
    um einen Hamiltonpfad im zugrundeliegenden Graphen zu generieren.
    Zunächst erfolgt eine Sortierung der Koordinaten nach nicht abnehmender euklidischer Entfernung von einem Startpunkt aus.
    Im Anschluss wird eine Schleife durchlaufen, in welcher jeder Punkt nacheinander besucht wird.
    Es wird geprüft, ob der aktuelle Punkt bereits in der Route vorhanden ist.
    Falls dies der Fall ist, wird mit dem nächsten Punkt fortgefahren.
    Andernfalls wird der Winkel zwischen den beiden zuletzt besuchten Punkten und dem aktuellen Punkt berechnet.
    Die Hinzunahme des aktuellen Punktes zur Route ist abhängig davon,
    ob die Route noch leer ist oder der Winkel zwischen den beiden Kanten größer oder gleich 90 Grad ist.
    Sobald alle Punkte der Menge in der Route enthalten sind, ist ein Hamiltonpfad gefunden und wird als wahr zurückgegeben.
    Andernfalls wird das letzte Element aus der Route entfernt und mit dem nächsten Punkt fortgefahren.

    Bei der Funktion \textsc{Schnittwinkel} handelt es sich um eine Hilfsmethode, welche den Winkel zwischen zwei Kanten berechnet,
    die von einem gemeinsamen Knoten ausgehen und zu anderen Knoten führen.
    Hierbei wird der Kosinussatz auf das Dreieck angewandt, welches von den drei Knoten gebildet wird
    und das Ergebnis der Berechnung wird in Grad zurückgegeben.

    \newpage
    \section{Umsetzung}\label{sec:umsetzung}
    Hier wird kurz erläutert, wie die Lösungsidee im Programm tatsächlich umgesetzt wurde.
    Hier können auch Implementierungsdetails erwähnt werden.

    \[
        P = \begin{pmatrix}
                x_1 \\
                y_1
        \end{pmatrix},
        \begin{pmatrix}
            x_2 \\
            y_2
        \end{pmatrix},
        \ldots,
        \begin{pmatrix}
            x_n \\
            y_n
        \end{pmatrix}
    \]

    \[
    P = \left{ (x_1,y_1), (x_2,y_2), \ldots, (x_n,y_n) \right}
    \]

    \newpage
    \section{Beispiele}\label{sec:beispiele}

\begin{figure}[H]
    \NewAdigraph{FigurFuenf}{
        1:0,0;
        2:1,0;
        3:2,0;
        4:3,0;
    }{
        1,2;
        2,3;
        3,4;
    }[-]
    \FigurFuenf{}
    \caption{Figur 5: Parcours mit mehreren Zielknoten}
    \label{fig:Figure1}
\end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe Figur 7., breaklines=true,label={lst:lstlisting2}]
  Ergebnis für Figur7.txt
    Der Parcours hat keine Lösung!
    \end{lstlisting}



    \begin{figure}[H]
        \NewAdigraph{FigurFuenf}{
            1:4,1;
            2:3,1.5;
            3:2,2;
            4:1.5,3;
            5:1,4;
            6:1.5,5;
            7:2,6;
            8:3,6.5;
            9:4,7;
            10:5,6.5;
            11:6,6;
            12:6.5,5;
            13:7,4;
            14:6.5,3;
            15:6,2;
            16:5,1.5;
        }{
            1,2;1,3;1,4;1,5;1,6;1,7;1,8;1,9;1,10;1,11;1,12;1,13;1,14;1,15;1,16;
            2,3;2,4;2,5;2,6;2,7;2,8;2,9;2,10;2,11;2,12;2,13;2,14;2,15;2,16;
            3,4;3,5;3,6;3,7;3,8;3,9;3,10;3,11;3,12;3,13;3,14;3,15;3,16;
            4,5;4,6;4,7;4,8;4,9;4,10;4,11;4,12;4,13;4,14;4,15;4,16;
            5,6;5,7;5,8;5,9;5,10;5,11;5,12;5,13;5,14;5,15;5,16;
            6,7;6,8;6,9;6,10;6,11;6,12;6,13;6,14;6,15;6,16;
            7,8;7,9;7,10;7,11;7,12;7,13;7,14;7,15;7,16;
            8,9;8,10;8,11;8,12;8,13;8,14;8,15;8,16;
            9,10;9,11;9,12;9,13;9,14;9,15;9,16;
            10,11;10,12;10,13;10,14;10,15;10,16;
            11,12;11,13;11,14;11,15;11,16;
            12,13;12,14;12,15;12,16;
            13,14;13,15;13,16;
            14,15;14,16;
            15,16;
        }[-]
        \FigurFuenf{}
        \caption{Figur 5: Parcours mit mehreren Zielknoten}
        \label{fig:Figure2}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe Figur 7., breaklines=true,label={lst:lstlisting}]
  Ergebnis für Figur7.txt
    Der Parcours hat keine Lösung!
    \end{lstlisting}


    \begin{figure}[H]
        \NewAdigraph{FigurFuenf}{
            1:0,0;
            2:1,0;
            3:0,1;
            4:1,1;
        }{
            1,2;
            2,3;
            3,4;
            1,4;
            2,3;
            1,3;
            2,4;
        }[-]
        \FigurFuenf{}
        \caption{Figur 5: Parcours mit mehreren Zielknoten}
        \label{fig:Figure3}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe Figur 7., breaklines=true,label={lst:lstlisting3}]
  Ergebnis für Figur7.txt
    Der Parcours hat keine Lösung!
    \end{lstlisting}


    \begin{figure}[H]
        \NewAdigraph{FigurFuenf}{
            1:0,1;
            2:0.5,0;
            3:1,1;
            4:2,0;
        }{
            1,2;
            2,3;
            3,4;
            1,4;
            2,3;
            1,3;
            2,4;
        }[-]
        \FigurFuenf{}
        \caption{Figur 5: Parcours mit mehreren Zielknoten}
        \label{fig:Figure3}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe Figur 7., breaklines=true,label={lst:lstlisting4}]
  Ergebnis für Figur7.txt
    Der Parcours hat keine Lösung!
    \end{lstlisting}
    
    \newpage
    \section{Quellcode}
    \label{sec:quellcode}
    \label{LastPage}
    \lstset{language=C++,
        keywordstyle=\color{magenta},
        stringstyle=\color{red},
        commentstyle=\color{green},
    }
    \begin{lstlisting}[frame=single,language=C++,title=Methode main,breaklines=true,label={lst:code_main}]
/**
 * Liest die Eingabedateien ein und berechnet für jede Datei eine Lösung entsprechend der Aufgabenstellung.
 * Die Lösung wird anschließend in die entsprechende Ausgabedatei geschrieben.
 * Sollte es keine Lösung geben, wird dies ebenfalls in die Ausgabedatei geschrieben.
 * @return Exitcode
 */
int main() {
    string input_dir = "../LennartProtte/Aufgabe1-Implementierung/Eingabedateien";
    string output_dir = "../LennartProtte/Aufgabe1-Implementierung/Ausgabedateien";

    //Durchläuft alle Dateien im Eingabeordner
    for (const std::filesystem::directory_entry &entry: filesystem::directory_iterator(input_dir)) {

        //Liest den Dateinamen aus
        string input_file = entry.path();
        string output_file = output_dir + "/" + entry.path().filename().string();

        //Öffnet die Eingabedatei
        ifstream fin(input_file);

        //Öffnet die Ausgabedatei
        ofstream fout(output_file);

        //Liest die Eingabedatei ein
        vector<pair<double, double> > coordinates;
        double x, y;
        while (fin >> x >> y) {
            coordinates.emplace_back(x, y);
        }

        //Berechnet die Lösung und schreibt das Ergebnis in die entsprechende Ausgabedatei
        vector<pair<double, double> > result;
        if (solve(result, coordinates)) {
            double distance = 0;
            for(int i = 0; i + 1 < result.size(); i++) {
                distance += sqrt(pow((result[i].first - result[i+1].first), 2.0) + (pow((result[i].second - result[i+1].second), 2.0)));
            }
            fout << "Es konnte eine " << distance << " km lange Flugstrecke durch alle Außenposten ermittelt werden." << endl;
            for (int i = 0; i < result.size(); i++) {
                fout << i + 1 << ". [" << result[i].first << ", " << result[i].second << "] ";
                if (i != 0 && i != result.size() - 1) {
                    fout << cross_angle(result[i - 1], result[i], result[i + 1]) << "° " << endl;
                } else {
                    fout << endl;
                }
            }
        } else {
            fout << "Es konnte keine Flugstrecke durch alle Außenposten ermittelt werden." << endl;
        }
    }
    return 0;
}
    \end{lstlisting}

    \newpage
    \begin{lstlisting}[frame=single,language=C++,title=Methode solve,breaklines=true,label={lst:code_solve}]
/**
 * Berechnet rekursiv mit Backtracking eine möglichst kurze Route durch den Graphen,
 * welche die Aufgabenkriterien erfüllt.
 * @param route die aktuelle Route
 * @param coordinates die Menge aller eingelesenen Koordinaten
 * @return true, wenn alle Knoten in der Lösungsmenge (route) enthalten sind, andernfalls false
 */
bool solve(vector<pair<double, double> > &route, vector<pair<double, double> > &coordinates) {
    //Sortiere nach dem nächsten Knoten
    if (!route.empty()) {
        const auto &last = route.back();
        sort(coordinates.begin(), coordinates.end(),
             [last](const auto &lhs, const auto &rhs) {
                 return sqrt(pow((last.first - lhs.first), 2.0) + (pow((last.second - lhs.second), 2.0)))
                        < sqrt(pow((last.first - rhs.first), 2.0) + (pow((last.second - rhs.second), 2.0)));
             });
    }
    //Für jeden Knoten
    for (int i = 0; i < coordinates.size(); i++) {
        //Wenn dieser Knoten bereits in der Lösungsmenge existiert, überspringe diesen
        if (std::find(route.begin(), route.end(), coordinates[i]) != route.end()) {
            continue;
        }
        double angle = -1;
        if (route.size() >= 2) {
            angle = cross_angle(route[route.size() - 2], route.back(), coordinates[i]);
        }
        if (route.empty() ||
            (std::find(route.begin(), route.end(), coordinates[i]) == route.end() &&
             (route.size() < 2 || angle >= 90))
                ) {
            //Füge den Knoten hinzu
            route.push_back(coordinates[i]);
            //Wenn alle Knoten in der Lösungsmenge sind
            if (route.size() == coordinates.size()) {
                return true;
            }
            //Wenn es eine Lösung mit der aktuellen Route gibt
            if (solve(route, coordinates)) {
                return true;
            } else {
                route.pop_back();
            }
        }
    }
//Wenn es mit der aktuellen Route keine Lösung geben kann
    return false;
}
    \end{lstlisting}

    \newpage
    \begin{lstlisting}[frame=single,language=C++,title=Methode cross\_angle,breaklines=true,label={lst:code_crossAngle}]
/**
 * Berechnet den Winkel in Grad zwischen den Vektoren von from_node nach over_node und over_node nach to_node
 * @param over_node der zweite Knoten
 * @param to_node der dritte Knoten (Zielknoten)
 * @param from_node der erste Knoten
 * @return false, wenn der Innenwinkel zwischen den Kanten kleiner als 90° beträgt, andernfalls true
 */
double cross_angle(const pair<double, double> &from_node,
                   const pair<double, double> &over_node,
                   const pair<double, double> &to_node) {
    double a, b, c;
    a = sqrt(pow((from_node.first - to_node.first), 2.0) + (pow((from_node.second - to_node.second), 2.0)));
    b = sqrt(pow((from_node.first - over_node.first), 2.0) + (pow((from_node.second - over_node.second), 2.0)));
    c = sqrt(pow((over_node.first - to_node.first), 2.0) + (pow((over_node.second - to_node.second), 2.0)));
    double angle = acos((pow(a, 2.0) - pow(b, 2.0) - pow(c, 2.0)) / (-2 * b * c)) * 180 / M_PI;
    return angle;
}
    \end{lstlisting}
\end{document}