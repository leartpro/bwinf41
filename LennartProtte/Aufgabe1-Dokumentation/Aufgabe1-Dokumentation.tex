%! Author = leartpro
%! Date = 04.01.23

\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 1: Weniger krumme Touren} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeilnahmeId}{67275}                        % Teilnahme-ID angeben
\newcommand{\Name}{Lennart Protte}                      % Name des Bearbeiter / der Bearbeiterin dieser Aufgabe angeben


% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Teilnahme-ID: \TeilnahmeId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

%Für Überschriften
\usepackage[labelformat=empty]{caption}
\captionsetup[algorithm]{labelformat=empty}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{adigraph}
\usepackage{algorithm}
\usepackage{algorithmicx}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
    keywordstyle=\color{blue},commentstyle=\color{mygreen},
    stringstyle=\color{mymauve},rulecolor=\color{black},
    basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
    captionpos=b, % sets the caption-position to bottom
    keepspaces=true, % keeps spaces in text
    numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
    showtabs=false, stepnumber=2, tabsize=2, title=\lstname ,
    inputencoding = utf8,  % Input encoding
    extendedchars = true,  % Extended ASCII
    literate      =        % Support additional characters
        {á}{{\'a}}1  {é}{{\'e}}1  {í}{{\'i}}1 {ó}{{\'o}}1  {ú}{{\'u}}1
        {Á}{{\'A}}1  {É}{{\'E}}1  {Í}{{\'I}}1 {Ó}{{\'O}}1  {Ú}{{\'U}}1
        {à}{{\`a}}1  {è}{{\`e}}1  {ì}{{\`i}}1 {ò}{{\`o}}1  {ù}{{\`u}}1
        {À}{{\`A}}1  {È}{{\'E}}1  {Ì}{{\`I}}1 {Ò}{{\`O}}1  {Ù}{{\`U}}1
        {ä}{{\"a}}1  {ë}{{\"e}}1  {ï}{{\"i}}1 {ö}{{\"o}}1  {ü}{{\"u}}1
        {Ä}{{\"A}}1  {Ë}{{\"E}}1  {Ï}{{\"I}}1 {Ö}{{\"O}}1  {Ü}{{\"U}}1
        {â}{{\^a}}1  {ê}{{\^e}}1  {î}{{\^i}}1 {ô}{{\^o}}1  {û}{{\^u}}1
        {Â}{{\^A}}1  {Ê}{{\^E}}1  {Î}{{\^I}}1 {Ô}{{\^O}}1  {Û}{{\^U}}1
        {œ}{{\oe}}1  {Œ}{{\OE}}1  {æ}{{\ae}}1 {Æ}{{\AE}}1  {ß}{{\ss}}1
        {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1  {Ø}{{\O}}1   {å}{{\r a}}1
        {Å}{{\r A}}1 {ã}{{\~a}}1  {õ}{{\~o}}1 {Ã}{{\~A}}1  {Õ}{{\~O}}1
        {ñ}{{\~n}}1  {Ñ}{{\~N}}1  {¿}{{?`}}1  {¡}{{!`}}1
        {°}{{\textdegree}}1 {º}{{\textordmasculine}}1 {ª}{{\textordfeminine}}1
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}
\usepackage{tikz}
\usepackage{amsfonts}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Teilnahme-ID: \LARGE \TeilnahmeId \\\\
\LARGE Bearbeiter/-in dieser Aufgabe: \\
\LARGE \Name\\\\}
\date{\LARGE\today}

\begin{document}

    \maketitle
    \tableofcontents
    \vspace{0.5cm}
    \newpage


    \section{Lösungsidee}\label{sec:losungsidee}

    Die vorliegende Aufgabe besteht darin, eine zulässige Reihenfolge zu ermitteln,
    in der Anton seine Außenstellen abfliegen kann,
    ohne dass es zu einem Innenwinkel von mehr als 90 Grad beim Abbiegen kommt.
    Dabei darf keine Außenstelle ausgelassen werden und weiter erscheint es nicht im Sinne der Außenstellung,
    dass eine Außenstelle nicht mehrfach besucht wird.
    Da in dieser Aufgabe nicht die kürzeste Route gesucht wird, kann eine approximierte Lösung angestrebt werden.
    \newline\newline
    Diese Problemstellung kann mit dem Handlungsreisendenproblem assoziiert werden,
    das darin besteht, einen möglichst kurzen Hamiltonkreis in einem gewichteten euklidischen Graphen zu finden.
    Im Gegensatz zum Handlungsreisendenproblem erfordert diese Aufgabe jedoch keinen identischen Start- und Endpunkt,
    sondern nur einen Hamiltonweg.
    Da das Hamiltonwegproblem NP-vollständig ist,
    existiert kein Algorithmus, der die gegebene Aufgabe deterministisch in Polynomialzeit lösen kann.
    \newline\newline
    Ein möglicher Lösungsansatz für dieses Problem ist die Verwendung einer Variante eines Greedy-Algorithmus,
    der die Nearest-Neighbour-Heuristik und Backtracking verwendet
    und das Winkelkriterium bei der Auswahl des nächsten Außenpostens beachtet.
    Alternativ könnten auch Algorithmen für konvexe Hüllen eingesetzt werden,
    obwohl diese für das Hamiltonpfadproblem weniger geeignet sind als für das Handlungsreisendenproblem.
    Die Implementierung eines solchen Algorithmus stellt jedoch eine höhere Schwierigkeit dar.
    Eine weitere Möglichkeit ist die Verwendung eines SAT-Solvers, der alle Permutationen der gegebenen Punktmenge durchgeht und
    jede Permutation auf ihre Erfüllbarkeit prüft.
    Da es jedoch für $n$ Elemente $n!$ Permutationen gibt, welche alle auf ihre Erfüllbarkeit geprüft werden müssten,
    könnte die Laufzeit sehr hoch ausfallen.
    \newline\newline
    Um eine Lösung mit dem Greedy-Algorithmus zu ermitteln,
    erfolgt zunächst eine Sortierung der Koordinaten nach nicht abnehmender euklidischer Entfernung von einem Startpunkt aus.
    Anschließend wird eine Schleife durchlaufen, in welcher jeder Punkt nacheinander besucht wird.
    Es wird geprüft, ob der aktuelle Punkt bereits in der Route vorhanden ist.
    Falls dies der Fall ist, wird mit dem nächsten Punkt fortgefahren.
    Andernfalls wird der Winkel zwischen den beiden zuletzt besuchten Punkten und dem aktuellen Punkt berechnet.
    Die Hinzunahme des aktuellen Punktes zur Route ist dabei abhängig davon, ob die Route noch leer ist oder der Winkel zwischen den beiden Kanten größer oder gleich 90 Grad ist.
    Sobald alle Punkte der Menge in der Route enthalten sind, ist ein Hamiltonpfad gefunden und wird als wahr zurückgegeben.
    Andernfalls wird das letzte Element aus der Route entfernt und mit dem nächsten Punkt fortgefahren.
    \newline\newline
    Die Funktion \textsc{HamiltonianPfad} erhält als Eingabe eine Menge von $n$ Punkten in der Ebene $P={(x,y)| x,y \in \mathbb{R}}$,
    dargestellt als Vektor von Paaren $\textit{koordinaten}=[(x_1,y_1), (x_2,y_2),\dots, (x_n,y_n)]$, und gibt einen Hamiltonpfad zurück,
    der alle Punkte in $\textit{koordinaten}$ verbindet, oder \textit{falsch}, falls ein solcher Pfad nicht existiert.
    Der Algorithmus arbeitet rekursiv und fügt schrittweise Punkte zur Lösungsmenge hinzu, bis entweder alle Elemente in der Lösungsmenge sind oder kein Element gibt,
    welches nach den Winkelkriterien als Nachfolger in Frage kommt.
    In diesem Fall wird das Backtracking eingesetzt, und der letzte Schritt wird rückgängig gemacht.
    Um den nächsten Außenposten auszuwählen, verwendet der Algorithmus die Nearest-Neighbour-Heuristik und beachtet zusätzlich das Winkelkriterium,
    um die Reihenfolge der Punkte im Pfad zu bestimmen.
    Dazu wird für jeden Punkt geprüft, ob er nach den Winkelkriterien als Nachfolger in Frage kommt.
    Die Laufzeit des Algorithmus ist O($n!$), da alle $n!$ Permutationen der gegebenen Punktmenge iteriert werden müssen, um eine Lösung zu finden.
    \newline\newline
    Der Greedy-Algorithmus wird verwendet, um einen Hamiltonpfad zu finden.
    Hierbei werden die Koordinaten nach der euklidischen Entfernung von einem Startpunkt aus sortiert.
    Eine Schleife durchläuft alle Punkte und prüft, ob der aktuelle Punkt bereits in der Route vorhanden ist.
    Falls dies der Fall ist, wird mit dem nächsten Punkt fortgefahren.
    Wenn nicht, wird der Winkel zwischen den zuletzt besuchten Punkten und dem aktuellen Punkt berechnet.
    Wenn entweder die Lösungsmenge $route$ leer ist, oder die Bedingung $\textit{koordinaten}[i] \notin \textit{route} \land (|\textit{route}|<2 \lor \textit{winkel} \geq 90$ erfüllt ist,
    wird der aktuelle Punkt zur Lösungsmenge hinzugefügt.
    Wenn alle Punkte in der Menge enthalten sind, ist ein Hamiltonpfad gefunden und wird als wahr zurückgegeben,
    andernfalls wird das letzte Element aus der Route entfernt und mit dem nächsten Punkt fortgefahren.
    Die Funktion \textsc{HamiltonianPfad} erhält eine Menge von Punkten als Eingabe und gibt einen Hamiltonpfad zurück oder \textit{falsch}, falls ein solcher Pfad nicht existiert.
    Die Laufzeit des Algorithmus ist O($n!$), da alle $n!$ Permutationen der gegebenen Punktmenge iteriert werden müssen, um eine Lösung zu finden.

    \begin{algorithm}[H]
        \caption{Finde einen Hamiltonpfad in einem euklidischen Graphen}
        \begin{algorithmic}
            \Require Eine Menge von $n$ Punkten in der Ebene $P={(x,y)| x,y \in \mathbb{R}}$, dargestellt als Vektor von Paaren $\textit{koordinaten}=[(x_1,y_1), (x_2,y_2),\dots, (x_n,y_n)]$.
            \Ensure Ein Hamiltonpfad im Graphen, der alle Punkte in $\textit{koordinaten}$ verbindet, oder $\textit{falsch}$, falls ein solcher Pfad nicht existiert.
            \Function{HamiltonianPfad}{$\textit{route},\ \textit{koordinaten}$}
                \If {$\textit{route}$ ist nicht leer}
                    \State $p\gets \textit{letztes Element von } \textit{route}$
                    \State $\textit{sortiere } \textit{koordinaten } \textit{nach nicht abnehmender euklidischer Entfernung zu } p$
                \EndIf
                \For{$i=1$ bis $n$}
                    \If {$\textit{koordinaten}[i]$ ist bereits in $\textit{route}$}
                        \State $\textbf{continue}$
                    \EndIf
                    \State $\textit{winkel}\gets -1$
                    \If {$\textit{route}$ hat mindestens zwei Elemente}
                        \State $\textit{winkel}\gets$ \textsc{Schnittwinkel}$(\textit{route}[|\textit{route}|-1], \textit{route}[|\textit{route}|], \textit{koordinaten}[i])$
                    \EndIf
                    \If {$\textit{route}$ ist leer \lor ($\textit{koordinaten}[i]$ \notin $\textit{route}$ \land ($|\textit{route}|<2$ \lor $\textit{winkel} \geq 90$))}
                        \State $\textit{füge }\textit{koordinaten}[i]\textit{ zu route hinzu}$
                        \If {$|\textit{route}|=n$}
                            \State \textbf{return} \textit{wahr}
                        \EndIf
                        \If {\textsc{HamiltonianPfad}$(\textit{route},\ \textit{koordinaten})$}
                            \State \textbf{return} \textit{wahr}
                        \Else
                            \State $\textit{entferne das letzte Element aus route}$
                        \EndIf
                    \EndIf
                \EndFor
                \State \textbf{return} \textit{falsch}
            \EndFunction
        \end{algorithmic}\label{alg:pseudo_greedy}
    \end{algorithm}

    Der Winkel zwischen zwei Kanten kann dabei über den Kosinussatz ermittelt werden,
    indem ein Dreieck aus dem vorletzten Punkt der Lösungsmenge,
    dem letzten Punkt der Lösungsmenge und dem aktuellen Punkt gebildet wird.

    Bei der Funktion \textsc{Schnittwinkel} handelt es sich um eine Hilfsmethode, welche diesen Winkel berechnet.
    Da $\arccos\left(\frac{a^2 - b^2 - c^2}{-2bc}\right)$ den Winkel in Bogenmaß zurückgibt,
    wird das Ergebnis in Grad umgerechnet, indem es mit $\frac{180}{\pi}$ multipliziert wird.


    \begin{algorithm}[H]
        \caption{Berechnet den Winkel zwischen zwei Kanten}
        \begin{algorithmic}
            \Function{Schnittwinkel}{$von_{knoten},\ddot uber_{knoten},zu_{knoten}$}
                \State $\textit{a}\gets \sqrt{(von_{knoten.x} - zu_{knoten.x})^2 + (von_{knoten.y} - zu_{knoten.y})^2}$
                \State $\textit{b}\gets \sqrt{(von_{knoten.x} - \ddot uber_{knoten.x})^2 + (von_{knoten.y} - \ddot uber_{knoten.y})^2}$
                \State $\textit{c}\gets \sqrt{(\ddot uber_{knoten.x} - zu_{knoten.x})^2 + (\ddot uber_{knoten.y} - zu_{knoten.y})^2}$
                \State $\textit{winkel} \gets \arccos\left(\frac{a^2 - b^2 - c^2}{-2bc}\right) \times \frac{180}{\pi}$
                \State \Return $winkel$
            \EndFunction
        \end{algorithmic}\label{alg:pseudo_crossangle}
    \end{algorithm}


    \newpage
    \section{Umsetzung}\label{sec:umsetzung}

    \[
        P = \begin{pmatrix}
                x_1 \\
                y_1
        \end{pmatrix},
        \begin{pmatrix}
            x_2 \\
            y_2
        \end{pmatrix},
        \ldots,
        \begin{pmatrix}
            x_n \\
            y_n
        \end{pmatrix}
    \]

    \[
    P = \left{ (x_1,y_1), (x_2,y_2), \ldots, (x_n,y_n) \right}
    \]

    - wie die Lösungsidee im Programm tatsächlich umgesetzt wurde
    - auch Implementierungsdetails
    - Transformation von Idee ins Programm
    - Bezug zwischen der Lösungsidee und der Implementation
    - in welchen Methoden die Algorithmen aus der Lösungsidee implementiert sind
    - wie bestimmte Konzepte der Lösungsidee elegant im Programm modelliert wurden

    Die gezeigten Funktionen sind in C++ geschrieben und basieren auf Standard-Datentypen wie Vektoren und Paaren.
    In der Funktion cross\_angle werden geometrische Berechnungen durchgeführt, um den Winkel in Grad zwischen den Vektoren von drei Knoten zu bestimmen.
    Hierbei werden die x- und y-Koordinaten jedes Knotens als double gespeichert und als pair<double, double>-Paar an die Funktion übergeben.
    Die Funktion verwendet die in C++ verfügbaren mathematischen Funktionen sqrt und pow, um die Wurzel und das Quadrat von Zahlen zu berechnen,
    sowie die trigonometrische Funktion acos, um den Inversen Kosinus (Arcuscosinus) einer Zahl zu berechnen.
    Der berechnete Winkel wird als double zurückgegeben.

    In der Funktion solve wird eine rekursive Backtracking-Methode verwendet, um eine möglichst kurze Route durch den Graphen zu berechnen.
    Hierzu werden ebenfalls Vektoren und Paare verwendet, um die Koordinaten aller Knoten zu speichern und die aktuelle Route zu halten.
    Zunächst wird die Liste der Knoten nach der Entfernung zum letzten Knoten der aktuellen Route sortiert.
    Dies wird durch die Verwendung von sort und einem Lambda-Ausdruck erreicht.
    Der Lambda-Ausdruck gibt an, wie die Vergleichsfunktion für das Sortieren verwendet werden soll.
    Wenn die Liste der Knoten sortiert ist, wird jeder Knoten in der Liste besucht und überprüft, ob er bereits in der Route enthalten ist oder nicht.
    Wenn der Knoten noch nicht in der Route enthalten ist, wird der Winkel zwischen dem Knoten, dem vorherigen Knoten und dem vor vorherigen Knoten (falls vorhanden) berechnet.
    Wenn der Winkel zwischen den Vektoren größer oder gleich 90 Grad ist oder die Route noch leer ist, wird der Knoten zur Route hinzugefügt.
    Wenn alle Knoten in der Lösungsmenge enthalten sind, wird true zurückgegeben, andernfalls wird das Backtracking fortgesetzt, um eine weitere mögliche Route zu finden.

    Die Verwendung von Vektoren und Paaren in C++ ist hier sinnvoll, da sie eine einfache und effiziente Möglichkeit bieten,
    eine Liste von Koordinaten und eine Liste von Knoten (in Form von Paaren von Koordinaten) zu speichern.
    Durch die Verwendung von std::find kann einfach überprüft werden, ob ein bestimmter Knoten bereits in der Route enthalten ist oder nicht.
    Die Verwendung von Lambda-Ausdrücken und Standardalgorithmen wie sort erleichtert die Implementierung des Algorithmus und erhöht die Lesbarkeit des Codes.

    Zusammenfassend verwendet der gezeigte Code Standard-C++-Funktionen wie Vektoren, Paare, Lambda-Ausdrücke und Standardalgorithmen,
    um eine rekursive Backtracking-Methode zur Lösung eines Routing-Problems zu implementieren.
    Die Verwendung von Standard-C++-Datentypen und Funktionen erleichtert die Implementierung des Algorithmus und erhöht die Lesbarkeit des Codes.

    \newline\newline
    Matrixdarstellung:
    Dabei repräsentieren $d_{i,j}$ die Entfernung zwischen Knoten $i$ und $j$.

    \begin{equation}
        \begin{bmatrix}
            0 & d{1,2} & d{1,3} & \cdots & d{1,n} \ d{2,1} & 0 & d{2,3} & \cdots & d{2,n} \ d{3,1} & d{3,2} &
            0 & \cdots & d{3,n} \ \vdots & \vdots & \vdots & \ddots & \vdots \ d{n,1} & d{n,2} & d{n,3} & \cdots &
            0
        \end{bmatrix}\label{eq:equation}
    \end{equation}

    Diagrammdarstellung:
    Ein Diagramm kann verwendet werden, um die Route durch den Graphen zu visualisieren.
    Im Folgenden ist ein Beispiel für ein solches Diagramm gegeben:

    \begin{figure}[htbp]
        \centering
        \begin{tikzpicture}[scale=1.5]
            \node[circle, draw] (a) at (0,0) {1};
            \node[circle, draw] (b) at (1,0) {2};
            \node[circle, draw] (c) at (2,0) {3};
            \node[circle, draw] (d) at (3,0) {4};
            \node[circle, draw] (e) at (4,0) {5};
            \node[circle, draw] (f) at (5,0) {6};
            \draw (a) -- (b) -- (c) -- (d) -- (e) -- (f);
            \draw[dashed, red] (a) -- (c) -- (e);
        \end{tikzpicture}
        \caption{Route durch den Graphen.}\label{fig:figure}
    \end{figure}

    In diesem Diagramm sind die Knoten als Kreise und die Verbindungen zwischen den Knoten als Linien dargestellt.
    Die rote gestrichelte Linie zeigt die Route durch den Graphen an.

    \begin{center}
        \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
        thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

        \node[main node] (1) {$1$};
        \node[main node] (2) [above right of=1] {$2$};
        \node[main node] (3) [below right of=2] {$3$};
        \node[main node] (4) [below right of=1] {$4$};

        \path[every node/.style={font=\sffamily\small}]
        (1) edge node [left] {4} (4)
        edge node [above] {2} (2)
        (2) edge node [right] {3} (3)
        (3) edge node [below] {1} (4);
        \end{tikzpicture}
    \end{center}

    \begin{figure}[h]
        \centering
        \begin{tikzpicture}[scale=1.5]
        % Define the coordinates of the nodes
            \coordinate[label=below:$from_{node}$] (fromNode) at (0,0);
            \coordinate[label=above:$over_{node}$] (overNode) at (1.5,1);
            \coordinate[label=below:$to_{node}$] (toNode) at (3,0);
        % Draw the edges between the nodes
            \draw (fromNode) -- node[above] {$a$} (overNode);
            \draw (overNode) -- node[above] {$c$} (toNode);
            \draw (fromNode) -- node[below] {$b$} (toNode);
        % Draw the angle symbol
            \draw [draw=black, fill=white] (0.7,0) arc (0:34:0.7);
            \node at (0.9,0.3) {$\alpha$};
        \end{tikzpicture}
        \caption{Visuelle Darstellung der Winkelberechnung}\label{fig:figure2}
    \end{figure}



    \newpage
    \section{Beispiele}\label{sec:beispiele}

\begin{figure}[H]
    \NewAdigraph{FigurFuenf}{
        1:0,0;
        2:1,0;
        3:2,0;
        4:3,0;
    }{
        1,2;
        2,3;
        3,4;
    }[-]
    \FigurFuenf{}
    \caption{Figur gerade.txt}
    \label{fig:Figure1}
\end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe gerade.txt, breaklines=true,label={lst:lstlisting2}]
    Es konnte eine 300 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [0, 0]
    2. [100, 0] 180°
    3. [200, 0] 180°
    4. [300, 0]

    \end{lstlisting}



    \begin{figure}[H]
        \NewAdigraph{FigurFuenf}{
            1:4,1;
            2:3,1.5;
            3:2,2;
            4:1.5,3;
            5:1,4;
            6:1.5,5;
            7:2,6;
            8:3,6.5;
            9:4,7;
            10:5,6.5;
            11:6,6;
            12:6.5,5;
            13:7,4;
            14:6.5,3;
            15:6,2;
            16:5,1.5;
        }{
            1,2;1,3;1,4;1,5;1,6;1,7;1,8;1,9;1,10;1,11;1,12;1,13;1,14;1,15;1,16;
            2,3;2,4;2,5;2,6;2,7;2,8;2,9;2,10;2,11;2,12;2,13;2,14;2,15;2,16;
            3,4;3,5;3,6;3,7;3,8;3,9;3,10;3,11;3,12;3,13;3,14;3,15;3,16;
            4,5;4,6;4,7;4,8;4,9;4,10;4,11;4,12;4,13;4,14;4,15;4,16;
            5,6;5,7;5,8;5,9;5,10;5,11;5,12;5,13;5,14;5,15;5,16;
            6,7;6,8;6,9;6,10;6,11;6,12;6,13;6,14;6,15;6,16;
            7,8;7,9;7,10;7,11;7,12;7,13;7,14;7,15;7,16;
            8,9;8,10;8,11;8,12;8,13;8,14;8,15;8,16;
            9,10;9,11;9,12;9,13;9,14;9,15;9,16;
            10,11;10,12;10,13;10,14;10,15;10,16;
            11,12;11,13;11,14;11,15;11,16;
            12,13;12,14;12,15;12,16;
            13,14;13,15;13,16;
            14,15;14,16;
            15,16;
        }[-]
        \FigurFuenf{}
        \caption{Figur kreis.txt}
        \label{fig:Figure2}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe kreis.txt, breaklines=true,label={lst:lstlisting}]
    Es konnte eine 1677.05 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [400, 100]
    2. [300, 150] 180°
    3. [200, 200] 143.13°
    4. [150, 300] 180°
    5. [100, 400] 126.87°
    6. [150, 500] 180°
    7. [200, 600] 143.13°
    8. [300, 650] 180°
    9. [400, 700] 126.87°
    10. [500, 650] 180°
    11. [600, 600] 143.13°
    12. [650, 500] 180°
    13. [700, 400] 126.87°
    14. [650, 300] 180°
    15. [600, 200] 143.13°
    16. [500, 150]
    \end{lstlisting}


    \begin{figure}[H]
        \NewAdigraph{FigurFuenf}{
            1:0,0;
            2:1,0;
            3:0,1;
            4:1,1;
        }{
            1,2;
            2,3;
            3,4;
            1,4;
            2,3;
            1,3;
            2,4;
        }[-]
        \FigurFuenf{}
        \caption{Figur viereck.txt}
        \label{fig:Figure3}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe viereck.txt, breaklines=true,label={lst:lstlisting3}]
    Es konnte eine 301.98 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [0, 0]
    2. [100, 0] 90°
    3. [100, 100] 101.31°
    4. [200, 120]
    \end{lstlisting}


    \begin{figure}[H]
        \NewAdigraph{FigurFuenf}{
            1:0,1;
            2:0.5,0;
            3:1,1;
            4:2,0;
        }{
            1,2;
            2,3;
            3,4;
            1,4;
            2,3;
            1,3;
            2,4;
        }[-]
        \FigurFuenf{}
        \caption{Figur nicht\_loesbar.txt}
        \label{fig:Figure3}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe nicht\_loesbar.txt, breaklines=true,label={lst:lstlisting4}]
    Es konnte keine Flugstrecke durch alle Außenposten ermittelt werden.
    \end{lstlisting}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm1.txt, breaklines=true,label={lst:lstlisting4}]
Es konnte eine 853.246 km lange Flugstrecke durch alle Außenposten ermittelt werden.
1. [200, 0]
2. [210, 0] 180°
3. [220, 0] 180°
4. [230, 0] 180°
5. [240, 0] 180°
6. [250, 0] 180°
7. [260, 0] 180°
8. [270, 0] 180°
9. [280, 0] 180°
10. [290, 0] 180°
11. [300, 0] 180°
12. [310, 0] 180°
13. [320, 0] 180°
14. [330, 0] 180°
15. [340, 0] 180°
16. [350, 0] 180°
17. [360, 0] 180°
18. [370, 0] 180°
19. [380, 0] 180°
20. [390, 0] 180°
21. [400, 0] 108.435°
22. [405, 15] 143.13°
23. [400, 30] 108.435°
24. [390, 30] 180°
25. [380, 30] 180°
26. [370, 30] 180°
27. [360, 30] 180°
28. [350, 30] 180°
29. [340, 30] 180°
30. [330, 30] 180°
31. [320, 30] 180°
32. [310, 30] 180°
33. [300, 30] 180°
34. [290, 30] 180°
35. [280, 30] 180°
36. [270, 30] 180°
37. [260, 30] 180°
38. [250, 30] 180°
39. [240, 30] 180°
40. [230, 30] 180°
41. [220, 30] 180°
42. [210, 30] 180°
43. [200, 30] 180°
44. [190, 30] 180°
45. [180, 30] 180°
46. [170, 30] 180°
47. [160, 30] 180°
48. [150, 30] 180°
49. [140, 30] 180°
50. [130, 30] 180°
51. [120, 30] 180°
52. [110, 30] 180°
53. [100, 30] 180°
54. [90, 30] 180°
55. [80, 30] 180°
56. [70, 30] 180°
57. [60, 30] 180°
58. [50, 30] 180°
59. [40, 30] 180°
60. [30, 30] 180°
61. [20, 30] 180°
62. [10, 30] 180°
63. [0, 30] 108.435°
64. [-5, 15] 143.13°
65. [0, 0] 108.435°
66. [10, 0] 180°
67. [20, 0] 180°
68. [30, 0] 180°
69. [40, 0] 180°
70. [50, 0] 180°
71. [60, 0] 180°
72. [70, 0] 180°
73. [80, 0] 180°
74. [90, 0] 180°
75. [100, 0] 180°
76. [110, 0] 180°
77. [120, 0] 180°
78. [130, 0] 180°
79. [140, 0] 180°
80. [150, 0] 180°
81. [160, 0] 180°
82. [170, 0] 180°
83. [180, 0] 180°
84. [190, 0]
    \end{lstlisting}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm2.txt, breaklines=true,label={lst:lstlisting4}]
Es konnte eine 2183.66 km lange Flugstrecke durch alle Außenposten ermittelt werden.
1. [81.3473, 182.709]
2. [117.557, 161.803] 168°
3. [148.629, 133.826] 168°
4. [173.205, 100] 168°
5. [190.211, 61.8034] 168°
6. [198.904, 20.9057] 168°
7. [198.904, -20.9057] 168°
8. [190.211, -61.8034] 168°
9. [173.205, -100] 168°
10. [148.629, -133.826] 168°
11. [117.557, -161.803] 168°
12. [81.3473, -182.709] 168°
13. [41.5823, -195.63] 168°
14. [0, -200] 168°
15. [-41.5823, -195.63] 168°
16. [-81.3473, -182.709] 168°
17. [-117.557, -161.803] 168°
18. [-148.629, -133.826] 168°
19. [-173.205, -100] 168°
20. [-190.211, -61.8034] 168°
21. [-198.904, -20.9057] 168°
22. [-198.904, 20.9057] 168°
23. [-190.211, 61.8034] 168°
24. [-173.205, 100] 168°
25. [-148.629, 133.826] 168°
26. [-117.557, 161.803] 168°
27. [-81.3473, 182.709] 168°
28. [-41.5823, 195.63] 168°
29. [0, 200] 168°
30. [41.5823, 195.63] 114.343°
31. [61.0105, 137.032] 138.343°
32. [88.1678, 121.353] 168°
33. [111.472, 100.37] 168°
34. [129.904, 75] 168°
35. [142.658, 46.3525] 168°
36. [149.178, 15.6793] 168°
37. [149.178, -15.6793] 168°
38. [142.658, -46.3525] 168°
39. [129.904, -75] 168°
40. [111.472, -100.37] 168°
41. [88.1678, -121.353] 168°
42. [61.0105, -137.032] 168°
43. [31.1868, -146.722] 168°
44. [0, -150] 168°
45. [-31.1868, -146.722] 168°
46. [-61.0105, -137.032] 168°
47. [-88.1678, -121.353] 168°
48. [-111.472, -100.37] 168°
49. [-129.904, -75] 168°
50. [-142.658, -46.3525] 168°
51. [-149.178, -15.6793] 168°
52. [-149.178, 15.6793] 168°
53. [-142.658, 46.3525] 168°
54. [-129.904, 75] 168°
55. [-111.472, 100.37] 168°
56. [-88.1678, 121.353] 168°
57. [-61.0105, 137.032] 168°
58. [-31.1868, 146.722] 168°
59. [0, 150] 168°
60. [31.1868, 146.722]
    \end{lstlisting}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm3.txt, breaklines=true,label={lst:lstlisting4}]
Es konnte eine 2102.94 km lange Flugstrecke durch alle Außenposten ermittelt werden.
1. [169.282, 140]
2. [176.085, 124.721] 168°
3. [179.562, 108.362] 168°
4. [179.562, 91.6377] 168°
5. [176.085, 75.2786] 168°
6. [169.282, 60] 147.349°
7. [159.452, 53.5304] 123.349°
8. [159.452, 46.4696] 123.349°
9. [169.282, 40] 147.349°
10. [176.085, 24.7214] 168°
11. [179.562, 8.36228] 168°
12. [179.562, -8.36228] 168°
13. [176.085, -24.7214] 168°
14. [169.282, -40] 168°
15. [159.452, -53.5304] 168°
16. [147.023, -64.7214] 168°
17. [132.539, -73.0836] 168°
18. [116.633, -78.2518] 168°
19. [100, -80] 168°
20. [83.3671, -78.2518] 168°
21. [67.4611, -73.0836] 168°
22. [52.9772, -64.7214] 150°
23. [47.0228, -64.7214] 120.051°
24. [40.5484, -53.5304] 174.051°
25. [30.718, -40] 168°
26. [23.9155, -24.7214] 168°
27. [20.4382, -8.36228] 168°
28. [20.4382, 8.36228] 164.131°
29. [16.6329, 21.7482] 96.339°
30. [23.9155, 24.7214] 172.073°
31. [32.5389, 26.9164] 96.3573°
32. [30.718, 40] 115.426°
33. [40.5484, 46.4696] 123.349°
34. [40.5484, 53.5304] 123.349°
35. [30.718, 60] 115.426°
36. [32.5389, 73.0836] 96.3573°
37. [23.9155, 75.2786] 172.073°
38. [16.6329, 78.2518] 96.339°
39. [20.4382, 91.6377] 164.131°
40. [20.4382, 108.362] 168°
41. [23.9155, 124.721] 168°
42. [30.718, 140] 168°
43. [40.5484, 153.53] 174.051°
44. [47.0228, 164.721] 120.051°
45. [52.9772, 164.721] 120.051°
46. [59.4516, 153.53] 174.051°
47. [69.282, 140] 168°
48. [76.0845, 124.721] 168°
49. [79.5618, 108.362] 168°
50. [79.5618, 91.6377] 164.131°
51. [83.3671, 78.2518] 96.339°
52. [76.0845, 75.2786] 172.073°
53. [67.4611, 73.0836] 96.3573°
54. [69.282, 60] 115.426°
55. [59.4516, 53.5304] 123.349°
56. [59.4516, 46.4696] 123.349°
57. [69.282, 40] 115.426°
58. [67.4611, 26.9164] 96.3573°
59. [76.0845, 24.7214] 172.073°
60. [83.3671, 21.7482] 96.339°
61. [79.5618, 8.36228] 164.131°
62. [79.5618, -8.36228] 168°
63. [76.0845, -24.7214] 168°
64. [69.282, -40] 168°
65. [59.4516, -53.5304] 162°
66. [32.5389, -73.0836] 162°
67. [16.6329, -78.2518] 168°
68. [0, -80] 168°
69. [-16.6329, -78.2518] 168°
70. [-32.5389, -73.0836] 168°
71. [-47.0228, -64.7214] 168°
72. [-59.4516, -53.5304] 168°
73. [-69.282, -40] 168°
74. [-76.0845, -24.7214] 168°
75. [-79.5618, -8.36228] 168°
76. [-79.5618, 8.36228] 168°
77. [-76.0845, 24.7214] 168°
78. [-69.282, 40] 147.349°
79. [-59.4516, 46.4696] 123.349°
80. [-59.4516, 53.5304] 123.349°
81. [-69.282, 60] 147.349°
82. [-76.0845, 75.2786] 168°
83. [-79.5618, 91.6377] 168°
84. [-79.5618, 108.362] 168°
85. [-76.0845, 124.721] 168°
86. [-69.282, 140] 168°
87. [-59.4516, 153.53] 168°
88. [-47.0228, 164.721] 168°
89. [-32.5389, 173.084] 168°
90. [-16.6329, 178.252] 168°
91. [0, 180] 168°
92. [16.6329, 178.252] 168°
93. [32.5389, 173.084] 162°
94. [67.4611, 173.084] 162°
95. [83.3671, 178.252] 168°
96. [100, 180] 168°
97. [116.633, 178.252] 168°
98. [132.539, 173.084] 168°
99. [147.023, 164.721] 168°
100. [159.452, 153.53] 113.503°
101. [132.539, 73.0836] 90.4971°
102. [116.633, 78.2518] 168°
103. [100, 80] 156°
104. [52.9772, 64.7214] 162°
105. [47.0228, 64.7214] 90°
106. [47.0228, 35.2786] 90°
107. [52.9772, 35.2786] 162°
108. [100, 20] 156°
109. [116.633, 21.7482] 168°
110. [132.539, 26.9164] 168°
111. [147.023, 35.2786] 120°
112. [147.023, 64.7214] 95.9329°
113. [0, 80] 168.067°
114. [-16.6329, 78.2518] 168°
115. [-32.5389, 73.0836] 168°
116. [-47.0228, 64.7214] 120°
117. [-47.0228, 35.2786] 120°
118. [-32.5389, 26.9164] 168°
119. [-16.6329, 21.7482] 168°
120. [0, 20]

    \end{lstlisting}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm4.txt, breaklines=true,label={lst:lstlisting4}]
Es konnte eine 2383.56 km lange Flugstrecke durch alle Außenposten ermittelt werden.
1. [20.2122, 156.013]
2. [33.3797, 100.161] 160.586°
3. [28.9137, 58.6999] 151.195°
4. [51.0081, 5.7696] 149.699°
5. [42.1378, -60.3199] 116.977°
6. [-82.8641, -104.174] 106.026°
7. [-98.7604, -81.7706] 176.676°
8. [-137.318, -20.1469] 113.448°
9. [-191.717, -28.3605] 179.89°
10. [-221.15, -32.8625] 105.541°
11. [-239.848, 8.6714] 154.98°
12. [-239.414, 40.4271] 131.945°
13. [-154.088, 115.023] 164.435°
14. [-119.026, 168.454] 91.8053°
15. [101.499, 33.4842] 170.242°
16. [139.447, 0.233238] 97.6677°
17. [94.7899, -67.0877] 145.005°
18. [-129.104, -155.042] 96.1933°
19. [-240.369, 57.4261] 127.717°
20. [-219.149, 103.685] 150.887°
21. [-107.989, 185.174] 105.549°
22. [153.13, -20.3609] 108.462°
23. [144.833, -43.4763] 98.9565°
24. [-16.7231, -12.6895] 131.852°
25. [-20.9712, -5.63711]

    \end{lstlisting}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm5.txt, breaklines=true,label={lst:lstlisting4}]
        --
    \end{lstlisting}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm6.txt, breaklines=true,label={lst:lstlisting4}]
Es konnte eine 4537.43 km lange Flugstrecke durch alle Außenposten ermittelt werden.
1. [102.909, 60.1079]
2. [100.007, 76.5793] 101.869°
3. [121.661, 85.2677] 110.933°
4. [120.906, 131.799] 107.158°
5. [132.794, 135.681] 173.798°
6. [154.871, 140.328] 104.799°
7. [175.678, 98.9293] 149.227°
8. [172.837, 59.1842] 96.8598°
9. [121.393, 56.6941] 165.524°
10. [83.0059, 64.6468] 147.533°
11. [64.559, 82.5676] 115.901°
12. [73.6898, 110.224] 101.849°
13. [85.0438, 108.946] 103.479°
14. [96.7817, 141.371] 90.8218°
15. [-55.0915, 198.827] 112.48°
16. [-89.4538, 162.237] 164.214°
17. [-100.569, 140.809] 141.804°
18. [-97.3917, 124.121] 158.665°
19. [-102.7, 95.6321] 146.056°
20. [-139.742, 57.9367] 105.133°
21. [-175.118, 77.8426] 159.554°
22. [-194.987, 101.364] 103.575°
23. [-167.995, 138.195] 121.39°
24. [21.0674, 122.165] 93.4215°
25. [20.2183, 88.0312] 118.574°
26. [56.7165, 66.9596] 124.377°
27. [58.0197, 49.9379] 177.956°
28. [58.7166, 32.8359] 124.192°
29. [40.3276, 19.216] 164.908°
30. [14.0056, -14.0153] 177.138°
31. [-4.59066, -40.0672] 172.54°
32. [-31.7454, -69.208] 102.46°
33. [-51.3438, -57.6548] 152.971°
34. [-72.5653, -24.2818] 119.462°
35. [-90.1602, -25.2008] 174.485°
36. [-126.57, -30.6452] 121.651°
37. [-144.888, -73.4954] 141.706°
38. [-189.988, -98.0439] 119.648°
39. [-191.216, -162.689] 164.33°
40. [-187.485, -177.031] 101.397°
41. [21.1766, -165.422] 129.477°
42. [46.6743, -193.09] 132.82°
43. [152.103, -193.381] 96.207°
44. [157.589, -144.201] 113.566°
45. [143.114, -135.867] 133.957°
46. [134.693, -102.153] 117.301°
47. [150.526, -88.2301] 140.051°
48. [155.405, -56.4379] 136.736°
49. [138.137, -31.3488] 109.69°
50. [112.833, -38.0576] 124.777°
51. [76.6471, -7.2897] 114.204°
52. [81.7404, 10.2763] 164.082°
53. [151.432, 121.427] 104.915°
54. [102.223, 174.202] 109.117°
55. [49.0919, 150.679] 135.158°
56. [-18.5074, -22.9053] 132.093°
57. [19.7653, -99.2364] 141.087°
58. [64.9434, -119.784] 111.657°
59. [92.2558, -93.5141] 174.618°
60. [155.342, -20.2528] 166.567°
61. [245.415, 44.7941] 106.396°
62. [231.945, 82.9611] 103.08°
63. [228.929, 82.625] 107.724°
64. [187.669, -122.656] 90.5419°
65. [210.186, -127.404] 143.93°
66. [221.029, -139.435] 112.306°
67. [238.583, -133.144] 124.723°
68. [289.299, 56.0513] 151.603°
69. [277.822, 104.263] 129.933°
70. [255.135, 115.595] 94.9634°
71. [246.622, 101.706] 155.191°
72. [216.826, -152.024] 111.984°
73. [245.021, -167.449] 110.076°
74. [242.81, -182.054] 108.442°
75. [202.347, -189.07] 155.68°
76. [-19.31, -131.811] 162.908°
77. [-107.197, -77.7926] 97.5915°
78. [-154.226, -135.522] 144.874°
79. [-288.744, -173.35] 107.052°
80. [-293.833, -165.44]
    \end{lstlisting}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm7.txt, breaklines=true,label={lst:lstlisting4}]
Es konnte eine 6249.18 km lange Flugstrecke durch alle Außenposten ermittelt werden.
1. [-47.2666, -66.984]
2. [-46.4031, -13.7558] 174.189°
3. [-48.3544, 9.09141] 163.939°
4. [-42.7047, 37.6795] 136.924°
5. [-27.912, 48.3267] 111.4°
6. [-4.43492, 33.1649] 174.235°
7. [3.15211, 27.1039] 112.693°
8. [-9.58087, -17.5166] 99.2591°
9. [-0.200936, -21.9277] 165.559°
10. [47.0114, -30.8872] 131.762°
11. [55.5509, -45.09] 117.138°
12. [88.8189, -42.8345] 125.038°
13. [118.99, -80.2036] 132.746°
14. [126.904, -80.7333] 144.922°
15. [172.389, -53.1333] 99.0328°
16. [158.552, -19.2544] 149.917°
17. [141.433, -6.02309] 91.0979°
18. [135.781, -13.0534] 174.726°
19. [68.9109, -82.1233] 170.13°
20. [34.9591, -106.842] 163.332°
21. [-17.3566, -125.254] 154.749°
22. [-133.731, -113.306] 139.255°
23. [-152.13, -93.8443] 148.711°
24. [-172.378, -88.2982] 140.926°
25. [-202.829, -101.7] 93.6351°
26. [-189.135, -139.079] 108.535°
27. [-155.652, -138.152] 93.9853°
28. [-147.363, 59.6082] 126.175°
29. [-185.649, 90.1445] 142.144°
30. [-189.062, 104.286] 135.847°
31. [-215.114, 120.741] 94.3003°
32. [-200.771, 147.741] 146.609°
33. [-201.485, 155.275] 150.007°
34. [-192.681, 174.523] 133.159°
35. [-153.13, 187.817] 133.67°
36. [-120.387, 170.589] 96.5546°
37. [-134.985, 132.945] 126.511°
38. [-157.423, 126.8] 153.219°
39. [-207.665, 81.4104] 139.712°
40. [-248.169, 80.1322] 141.169°
41. [-284.129, 107.253] 151.797°
42. [-287.058, 113.6] 123.54°
43. [-268.739, 143.276] 173.374°
44. [-240.249, 179.335] 98.1925°
45. [-222.492, 169.033] 138.615°
46. [-114.146, 190.615] 113.581°
47. [-84.6269, 148.216] 99.6777°
48. [-126.569, 106.965] 163.314°
49. [-171.355, 25.4631] 175.937°
50. [-184.093, 5.73728] 126.976°
51. [-226.788, 2.65886] 103.204°
52. [-244.96, -111.047] 132.913°
53. [-181.209, -192.623] 122.813°
54. [59.8272, -170.714] 148.109°
55. [92.298, -146.169] 147.35°
56. [106.599, -107.434] 150.022°
57. [205.718, -24.9765] 112.76°
58. [224.599, -34.7985] 111.954°
59. [239.617, -21.9442] 102.558°
60. [276.277, -49.4487] 129.242°
61. [278.105, -93.7718] 173.926°
62. [275.793, -129.415] 113.555°
63. [235.827, -143.839] 131.711°
64. [217.599, -189.258] 93.3155°
65. [-217.282, -43.3166] 103.844°
66. [-211.429, 27.7704] 117.437°
67. [-56.9145, 92.5012] 166.179°
68. [16.5732, 104.021] 124.328°
69. [40.8971, 78.1523] 158.984°
70. [54.5519, 71.5671] 152.652°
71. [56.3898, 71.6185] 97.593°
72. [57.5554, 64.4173] 125.102°
73. [129.024, 29.7017] 106.168°
74. [158.742, 62.6188] 142.283°
75. [162.923, 117.466] 107.996°
76. [148.108, 123.558] 130.701°
77. [126.8, 112.727] 126.849°
78. [120.375, 115.89] 140.328°
79. [100.044, 161.295] 166.435°
80. [95.9472, 183.278] 99.0245°
81. [130.855, 195.695] 119.378°
82. [170.514, 161.17] 126.706°
83. [169.99, 154.26] 94.4381°
84. [54.7665, 154.054] 92.7867°
85. [53.4365, 125.683] 151.877°
86. [74.8875, 80.5865] 138.298°
87. [178.198, 37.032] 108.571°
88. [271.301, 142.524] 90.0238°
89. [221.808, 186.241] 135.732°
90. [-13.0303, 174.698] 94.8741°
91. [-18.3161, 27.7559] 96.7579°
92. [189.387, -4.46523] 90.8201°
93. [216.691, 156.314] 174.146°
94. [217.219, 164.295] 93.508°
95. [34.079, 187.731] 108.85°
96. [8.64366, 135.907] 121.263°
97. [55.4348, 62.7292] 96.8409°
98. [208.593, 136.618] 102.802°
99. [296.912, 25.8116] 112.261°
100. [256.476, -46.5914]

    \end{lstlisting}
    
    \newpage
    \section{Quellcode}
    \label{sec:quellcode}
    \label{LastPage}
    \lstset{language=C++,
        keywordstyle=\color{magenta},
        stringstyle=\color{red},
        commentstyle=\color{green},
    }
    \begin{lstlisting}[frame=single,language=C++,title=Methode main,breaklines=true,label={lst:code_main}]
/**
 * Liest die Eingabedateien ein und berechnet für jede Datei eine Lösung entsprechend der Aufgabenstellung.
 * Die Lösung wird anschließend in die entsprechende Ausgabedatei geschrieben.
 * Sollte es keine Lösung geben, wird dies ebenfalls in die Ausgabedatei geschrieben.
 * @return Exitcode
 */
int main() {
    string input_dir = "../LennartProtte/Aufgabe1-Implementierung/Eingabedateien";
    string output_dir = "../LennartProtte/Aufgabe1-Implementierung/Ausgabedateien";

    //Durchläuft alle Dateien im Eingabeordner
    for (const std::filesystem::directory_entry &entry: filesystem::directory_iterator(input_dir)) {

        //Liest den Dateinamen aus
        string input_file = entry.path();
        string output_file = output_dir + "/" + entry.path().filename().string();

        //Öffnet die Eingabedatei
        ifstream fin(input_file);

        //Öffnet die Ausgabedatei
        ofstream fout(output_file);

        //Liest die Eingabedatei ein
        vector<pair<double, double> > coordinates;
        double x, y;
        while (fin >> x >> y) {
            coordinates.emplace_back(x, y);
        }

        //Berechnet die Lösung und schreibt das Ergebnis in die entsprechende Ausgabedatei
        vector<pair<double, double> > result;
        if (solve(result, coordinates)) {
            double distance = 0;
            for(int i = 0; i + 1 < result.size(); i++) {
                distance += sqrt(pow((result[i].first - result[i+1].first), 2.0) + (pow((result[i].second - result[i+1].second), 2.0)));
            }
            fout << "Es konnte eine " << distance << " km lange Flugstrecke durch alle Außenposten ermittelt werden." << endl;
            for (int i = 0; i < result.size(); i++) {
                fout << i + 1 << ". [" << result[i].first << ", " << result[i].second << "] ";
                if (i != 0 && i != result.size() - 1) {
                    fout << cross_angle(result[i - 1], result[i], result[i + 1]) << "° " << endl;
                } else {
                    fout << endl;
                }
            }
        } else {
            fout << "Es konnte keine Flugstrecke durch alle Außenposten ermittelt werden." << endl;
        }
    }
    return 0;
}
    \end{lstlisting}

    \newpage
    \begin{lstlisting}[frame=single,language=C++,title=Methode solve,breaklines=true,label={lst:code_solve}]
/**
 * Berechnet rekursiv mit Backtracking eine möglichst kurze Route durch den Graphen,
 * welche die Aufgabenkriterien erfüllt.
 * @param route die aktuelle Route
 * @param coordinates die Menge aller eingelesenen Koordinaten
 * @return true, wenn alle Knoten in der Lösungsmenge (route) enthalten sind, andernfalls false
 */
bool solve(vector<pair<double, double> > &route, vector<pair<double, double> > &coordinates) {
    //Sortiere nach dem nächsten Knoten
    if (!route.empty()) {
        const auto &last = route.back();
        sort(coordinates.begin(), coordinates.end(),
             [last](const auto &lhs, const auto &rhs) {
                 return sqrt(pow((last.first - lhs.first), 2.0) + (pow((last.second - lhs.second), 2.0)))
                        < sqrt(pow((last.first - rhs.first), 2.0) + (pow((last.second - rhs.second), 2.0)));
             });
    }
    //Für jeden Knoten
    for (int i = 0; i < coordinates.size(); i++) {
        //Wenn dieser Knoten bereits in der Lösungsmenge existiert, überspringe diesen
        if (std::find(route.begin(), route.end(), coordinates[i]) != route.end()) {
            continue;
        }
        double angle = -1;
        if (route.size() >= 2) {
            angle = cross_angle(route[route.size() - 2], route.back(), coordinates[i]);
        }
        if (route.empty() ||
            (std::find(route.begin(), route.end(), coordinates[i]) == route.end() &&
             (route.size() < 2 || angle >= 90))
                ) {
            //Füge den Knoten hinzu
            route.push_back(coordinates[i]);
            //Wenn alle Knoten in der Lösungsmenge sind
            if (route.size() == coordinates.size()) {
                return true;
            }
            //Wenn es eine Lösung mit der aktuellen Route gibt
            if (solve(route, coordinates)) {
                return true;
            } else {
                route.pop_back();
            }
        }
    }
//Wenn es mit der aktuellen Route keine Lösung geben kann
    return false;
}
    \end{lstlisting}

    \newpage
    \begin{lstlisting}[frame=single,language=C++,title=Methode cross\_angle,breaklines=true,label={lst:code_crossAngle}]
/**
 * Berechnet den Winkel in Grad zwischen den Vektoren von from_node nach over_node und over_node nach to_node
 * @param over_node der zweite Knoten
 * @param to_node der dritte Knoten (Zielknoten)
 * @param from_node der erste Knoten
 * @return false, wenn der Innenwinkel zwischen den Kanten kleiner als 90° beträgt, andernfalls true
 */
double cross_angle(const pair<double, double> &from_node,
                   const pair<double, double> &over_node,
                   const pair<double, double> &to_node) {
    double a, b, c;
    a = sqrt(pow((from_node.first - to_node.first), 2.0) + (pow((from_node.second - to_node.second), 2.0)));
    b = sqrt(pow((from_node.first - over_node.first), 2.0) + (pow((from_node.second - over_node.second), 2.0)));
    c = sqrt(pow((over_node.first - to_node.first), 2.0) + (pow((over_node.second - to_node.second), 2.0)));
    double angle = acos((pow(a, 2.0) - pow(b, 2.0) - pow(c, 2.0)) / (-2 * b * c)) * 180 / M_PI;
    return angle;
}
    \end{lstlisting}
\end{document}