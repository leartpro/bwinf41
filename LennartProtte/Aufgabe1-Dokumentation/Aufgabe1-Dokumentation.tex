%! Author = leartpro
%! Date = 04.01.23

\documentclass[a4paper,10pt,ngerman]{scrartcl}
\usepackage{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage[a4paper,margin=2.5cm,footskip=0.5cm]{geometry}

% Die nächsten drei Felder bitte anpassen:
\newcommand{\Aufgabe}{Aufgabe 1: Weniger krumme Touren} % Aufgabennummer und Aufgabennamen angeben
\newcommand{\TeilnahmeId}{67275}                        % Teilnahme-ID angeben
\newcommand{\Name}{Lennart Protte}                      % Name des Bearbeiter / der Bearbeiterin dieser Aufgabe angeben


% Kopf- und Fußzeilen
\usepackage{scrlayer-scrpage, lastpage}
\setkomafont{pageheadfoot}{\large\textrm}
\lohead{\Aufgabe}
\rohead{Teilnahme-ID: \TeilnahmeId}
\cfoot*{\thepage{}/\pageref{LastPage}}

% Position des Titels
\usepackage{titling}
\setlength{\droptitle}{-1.0cm}

% Für mathematische Befehle und Symbole
\usepackage{amsmath}
\usepackage{amssymb}

% Für Bilder
\usepackage{graphicx}

%Für Überschriften
\usepackage[labelformat=empty]{caption}
\captionsetup[algorithm]{labelformat=empty}

% Für Algorithmen
\usepackage{algpseudocode}
\usepackage{adigraph}
\usepackage{algorithm}
\usepackage{algorithmicx}

% Für Quelltext
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
    keywordstyle=\color{blue},commentstyle=\color{mygreen},
    stringstyle=\color{mymauve},rulecolor=\color{black},
    basicstyle=\footnotesize\ttfamily,numberstyle=\tiny\color{mygray},
    captionpos=b, % sets the caption-position to bottom
    keepspaces=true, % keeps spaces in text
    numbers=left, numbersep=5pt, showspaces=false,showstringspaces=true,
    showtabs=false, stepnumber=2, tabsize=2, title=\lstname ,
    inputencoding = utf8,  % Input encoding
    extendedchars = true,  % Extended ASCII
    literate      =        % Support additional characters
        {á}{{\'a}}1  {é}{{\'e}}1  {í}{{\'i}}1 {ó}{{\'o}}1  {ú}{{\'u}}1
        {Á}{{\'A}}1  {É}{{\'E}}1  {Í}{{\'I}}1 {Ó}{{\'O}}1  {Ú}{{\'U}}1
        {à}{{\`a}}1  {è}{{\`e}}1  {ì}{{\`i}}1 {ò}{{\`o}}1  {ù}{{\`u}}1
        {À}{{\`A}}1  {È}{{\'E}}1  {Ì}{{\`I}}1 {Ò}{{\`O}}1  {Ù}{{\`U}}1
        {ä}{{\"a}}1  {ë}{{\"e}}1  {ï}{{\"i}}1 {ö}{{\"o}}1  {ü}{{\"u}}1
        {Ä}{{\"A}}1  {Ë}{{\"E}}1  {Ï}{{\"I}}1 {Ö}{{\"O}}1  {Ü}{{\"U}}1
        {â}{{\^a}}1  {ê}{{\^e}}1  {î}{{\^i}}1 {ô}{{\^o}}1  {û}{{\^u}}1
        {Â}{{\^A}}1  {Ê}{{\^E}}1  {Î}{{\^I}}1 {Ô}{{\^O}}1  {Û}{{\^U}}1
        {œ}{{\oe}}1  {Œ}{{\OE}}1  {æ}{{\ae}}1 {Æ}{{\AE}}1  {ß}{{\ss}}1
        {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1  {Ø}{{\O}}1   {å}{{\r a}}1
        {Å}{{\r A}}1 {ã}{{\~a}}1  {õ}{{\~o}}1 {Ã}{{\~A}}1  {Õ}{{\~O}}1
        {ñ}{{\~n}}1  {Ñ}{{\~N}}1  {¿}{{?`}}1  {¡}{{!`}}1
        {°}{{\textdegree}}1 {º}{{\textordmasculine}}1 {ª}{{\textordfeminine}}1
}

% Diese beiden Pakete müssen zuletzt geladen werden
\usepackage{hyperref} % Anklickbare Links im Dokument
\usepackage{cleveref}
\usepackage{tikz}
\usetikzlibrary{graphs}
\usetikzlibrary{angles}
\usetikzlibrary{quotes}
\usepackage{amsfonts}

% Daten für die Titelseite
\title{\textbf{\Huge\Aufgabe}}
\author{\LARGE Teilnahme-ID: \LARGE \TeilnahmeId \\\\
\LARGE Bearbeiter dieser Aufgabe: \\
\LARGE \Name\\\\}
\date{\LARGE\today}

\begin{document}

    \maketitle
    \tableofcontents
    \vspace{0.5cm}
    \newpage


    \section{Lösungsidee}\label{sec:losungsidee}
    \subsection{Einleitung}\label{subsec:einleitung}

    Die vorliegende Aufgabe besteht darin, eine zulässige Reihenfolge zu ermitteln,
    in der Anton seine Außenstellen abfliegen kann,
    ohne dass es zu einem Innenwinkel von mehr als 90 Grad beim Abbiegen kommt.
    Dabei darf keine Außenstelle ausgelassen werden und weiter erscheint es nicht im Sinne der Außenstellung,
    dass eine Außenstelle nicht mehrfach besucht wird.
    Da in dieser Aufgabe nicht die kürzeste Route gesucht wird, kann eine approximierte Lösung angestrebt werden.

    \subsection{Abstraktion}\label{subsec:abstraktion}

    Diese Problemstellung kann mit dem Handlungsreisendenproblem assoziiert werden,
    das darin besteht, einen möglichst kurzen Hamiltonkreis in einem gewichteten euklidischen Graphen zu finden.
    Im Gegensatz zum Handlungsreisendenproblem erfordert diese Aufgabe jedoch keinen identischen Start- und Endpunkt,
    sondern nur einen Hamiltonweg.
    Da das Hamiltonwegproblem NP-vollständig ist,
    existiert kein Algorithmus, der die gegebene Aufgabe deterministisch in Polynomialzeit lösen kann.
    \subsection{Lösungsverfahren}\label{subsec:losungsverfahren}
    Ein möglicher Lösungsansatz für dieses Problem ist die Verwendung einer Variante eines Greedy-Algorithmus,
    der die Nearest-Neighbour-Heuristik und Backtracking verwendet
    und das Winkelkriterium bei der Auswahl des nächsten Außenpostens beachtet.
    Alternativ könnten auch Algorithmen für konvexe Hüllen eingesetzt werden,
    obwohl diese für das Hamiltonpfadproblem weniger geeignet sind als für das Handlungsreisendenproblem.
    Die Implementierung eines solchen Algorithmus stellt jedoch eine höhere Schwierigkeit dar.
    Eine weitere Möglichkeit ist die Verwendung eines SAT-Solvers, der alle Permutationen der gegebenen Punktmenge durchgeht und
    jede Permutation auf ihre Erfüllbarkeit prüft.
    Da es jedoch für $n$ Elemente $n!$ Permutationen gibt, welche alle auf ihre Erfüllbarkeit geprüft werden müssten,
    könnte die Laufzeit sehr hoch ausfallen.
    \subsection{Algorithmus}\label{subsec:algorithmus}

    Zunächst erfolgt eine Sortierung der Koordinaten nach nicht abnehmender euklidischer Entfernung von einem Startpunkt aus,
    um die Nearest-Neighbour-Heuristik zu realisieren.
    Anschließend wird eine Schleife durchlaufen, in welcher jeder Punkt nacheinander besucht wird.
    Anschließend wird für jeden Knoten der Menge geprüft, ob der aktuelle Punkt bereits in der Lösungsmenge $route$ vorhanden ist.
    Falls dies der Fall ist, wird mit dem nächsten Punkt fortgefahren.
    Andernfalls wird der Winkel zwischen den beiden zuletzt besuchten Punkten und dem aktuellen Punkt berechnet.
    Wenn entweder die Lösungsmenge $route$ leer ist, oder die Bedingung $\textit{koordinaten}[i] \notin \textit{route} \land (|\textit{route}|<2 \lor \textit{winkel} \geq 90$ erfüllt ist,
    wird der aktuelle Punkt zur Lösungsmenge hinzugefügt.
    Befinden sich nun alle Punkte in der Lösungsmenge, ist ein Hamiltonpfad gefunden und wird als wahr zurückgegeben.
    Ansonsten arbeitet der Algorithmus rekursiv, indem er sich für jeden, zur Lösungsmenge hinzugefügten Punkt, selbst aufruft.
    Wenn alle Punkte, die sich noch nicht in der Lösungsmenge befinden, nicht unter berücksichtigung des Winkelkriteriums erreichbar sind,
    wird das Backtracking eingesetzt, und der letzte Schritt wird rückgängig gemacht.
    Die worst-case-Laufzeit des Algorithmus ist O($n!$), da im Fall,
    dass keine Lösung existiert alle $n!$ Permutationen der gegebenen Punktmenge iteriert werden müssen, um eine Lösung zu finden.

    \begin{algorithm}[H]
        \caption{Finde einen Hamiltonpfad in einem euklidischen Graphen}
        \begin{algorithmic}
            \Require Eine Menge von $n$ Punkten in der Ebene $P={(x,y)| x,y \in \mathbb{R}}$, dargestellt als Menge von Paaren $\textit{koordinaten}=[(x_1,y_1), (x_2,y_2),\dots, (x_n,y_n)]$.
            \Ensure Ein Hamiltonpfad im Graphen, der alle Punkte in $\textit{koordinaten}$ verbindet, oder $\textit{falsch}$, falls ein solcher Pfad nicht existiert.
            \Function{HamiltonianPfad}{$\textit{route},\ \textit{koordinaten}$}
                \If {$\textit{route}$ ist nicht leer}
                    \State $p\gets \textit{letztes Element von } \textit{route}$
                    \State $\textit{sortiere } \textit{koordinaten } \textit{nach nicht abnehmender euklidischer Entfernung zu } p$
                \EndIf
                \For{$i=1$ bis $n$}
                    \If {$\textit{koordinaten}[i]$ ist bereits in $\textit{route}$}
                        \State $\textbf{continue}$
                    \EndIf
                    \State $\textit{winkel}\gets -1$
                    \If {$\textit{route}$ hat mindestens zwei Elemente}
                        \State $\textit{winkel}\gets$ \textsc{Schnittwinkel}$(\textit{route}[|\textit{route}|-1], \textit{route}[|\textit{route}|], \textit{koordinaten}[i])$
                    \EndIf
                    \If {$\textit{route}$ ist leer \lor ($\textit{koordinaten}[i]$ \notin $\textit{route}$ \land ($|\textit{route}|<2$ \lor $\textit{winkel} \geq 90$))}
                        \State $\textit{füge }\textit{koordinaten}[i]\textit{ zu route hinzu}$
                        \If {$|\textit{route}|=n$}
                            \State \textbf{return} \textit{wahr}
                        \EndIf
                        \If {\textsc{HamiltonianPfad}$(\textit{route},\ \textit{koordinaten})$}
                            \State \textbf{return} \textit{wahr}
                        \Else
                            \State $\textit{entferne das letzte Element aus route}$
                        \EndIf
                    \EndIf
                \EndFor
                \State \textbf{return} \textit{falsch}
            \EndFunction
        \end{algorithmic}\label{alg:pseudo_greedy}
    \end{algorithm}

    Der Winkel zwischen zwei Kanten kann dabei über den Kosinussatz ermittelt werden,
    indem ein Dreieck aus dem vorletzten Punkt der Lösungsmenge,
    dem letzten Punkt der Lösungsmenge und dem aktuellen Punkt gebildet wird.
    So wird in der \hyperref[fig:figure2]{Figur Winkelberechnung} eine Berechnung des Winkels $\alpha$ zwischen den Kanten
    $from_{node}$ - $over_{node}$ und $over_{node}$ - $to_{node}$ dargestellt.

    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[scale=1.5]
            % Define the coordinates of the nodes
            \coordinate[label=below:$over_{node}$] (fromNode) at (0,0);
            \coordinate[label=above:$to_{node}$] (overNode) at (1.5,1);
            \coordinate[label=below:$from_{node}$] (toNode) at (3,0);
            % Draw the edges between the nodes
            \draw (fromNode) -- node[above] {$b$} (overNode);
            \draw (overNode) -- node[above] {$c$} (toNode);
            \draw (fromNode) -- node[below] {$a$} (toNode);
            % Draw the angle symbol
            \draw [draw=black, fill=white] (0.7,0) arc (0:34:0.7);
            \node at (0.9,0.3) {$\alpha$};
        \end{tikzpicture}
        \caption{Figur: Winkelberechnung}\label{fig:figure2}
    \end{figure}

    Bei der Funktion \hyperref[alg:pseudo_crossangle]{\textsc{Schnittwinkel}} handelt es sich um eine Hilfsmethode, welche diesen Winkel berechnet.
    Da $\arccos\left(\frac{a^2 - b^2 - c^2}{-2bc}\right)$ den Winkel in Bogenmaß zurückgibt,
    wird das Ergebnis in Grad umgerechnet, indem es mit $\frac{180}{\pi}$ multipliziert wird.


    \begin{algorithm}[H]
        \caption{Berechnet den Winkel zwischen zwei Kanten}
        \begin{algorithmic}
            \Function{Schnittwinkel}{$von_{knoten},\ddot uber_{knoten},zu_{knoten}$}
                \State $\textit{a}\gets \sqrt{(von_{knoten.x} - zu_{knoten.x})^2 + (von_{knoten.y} - zu_{knoten.y})^2}$
                \State $\textit{b}\gets \sqrt{(von_{knoten.x} - \ddot uber_{knoten.x})^2 + (von_{knoten.y} - \ddot uber_{knoten.y})^2}$
                \State $\textit{c}\gets \sqrt{(\ddot uber_{knoten.x} - zu_{knoten.x})^2 + (\ddot uber_{knoten.y} - zu_{knoten.y})^2}$
                \State $\textit{winkel} \gets \arccos\left(\frac{a^2 - b^2 - c^2}{-2bc}\right) \times \frac{180}{\pi}$
                \State \Return $winkel$
            \EndFunction
        \end{algorithmic}\label{alg:pseudo_crossangle}
    \end{algorithm}

    \section{Umsetzung}\label{sec:umsetzung}

    \subsection{Methoden}\label{subsec:methoden}
    In der Funktion cross\_angle werden geometrische Berechnungen durchgeführt, um den Winkel in Grad zwischen den Vektoren von drei Knoten zu bestimmen.
    Hierbei werden die x- und y-Koordinaten jedes Knotens als double gespeichert und als pair<double, double>-Paar an die Funktion übergeben.
    Die Funktion verwendet die in C++ verfügbaren mathematischen Funktionen sqrt und pow, um die Wurzel und das Quadrat von Zahlen zu berechnen,
    sowie die trigonometrische Funktion acos, um den Inversen Kosinus (Arcuscosinus) einer Zahl zu berechnen.
    Der berechnete Winkel wird als double zurückgegeben.
    \newline

    In der Funktion solve wird eine rekursive Backtracking-Methode verwendet, um eine möglichst kurze Route durch den Graphen zu berechnen.
    Hierzu werden ebenfalls Vektoren und Paare verwendet, um die Koordinaten aller Knoten zu speichern und die aktuelle Route zu halten.
    Zunächst wird die Liste der Knoten nach der Entfernung zum letzten Knoten der aktuellen Route sortiert.
    Dies wird durch die Verwendung von sort und einem Lambda-Ausdruck erreicht.
    Der Lambda-Ausdruck gibt an, wie die Vergleichsfunktion für das Sortieren verwendet werden soll.
    Wenn die Liste der Knoten sortiert ist, wird jeder Knoten in der Liste besucht und überprüft, ob er bereits in der Route enthalten ist oder nicht.
    Wenn der Knoten noch nicht in der Route enthalten ist, wird der Winkel zwischen dem Knoten, dem vorherigen Knoten und dem vor vorherigen Knoten (falls vorhanden) berechnet.
    Wenn der Winkel zwischen den Vektoren größer oder gleich 90 Grad ist oder die Route noch leer ist, wird der Knoten zur Route hinzugefügt.
    Wenn alle Knoten in der Lösungsmenge enthalten sind, wird true zurückgegeben, andernfalls wird das Backtracking fortgesetzt, um eine weitere mögliche Route zu finden.

    \subsection{Transformation}\label{subsec:transformation}

    -darstellung in list form sprat zeit, da sonst unnötig kanten betrachtet werden


    \begin{figure}[htbp]
        \centering
        \begin{tikzpicture}[scale=1.5]
            \node[circle, draw] (a) at (0,0) {1};
            \node[circle, draw] (b) at (1,0) {2};
            \node[circle, draw] (c) at (2,0) {3};
            \node[circle, draw] (d) at (3,0) {4};
            \node[circle, draw] (e) at (4,0) {5};
            \node[circle, draw] (f) at (5,0) {6};
            \draw (a) -- (b) -- (c) -- (d) -- (e) -- (f);
            \draw[dashed, red] (a) -- (c) -- (e);
        \end{tikzpicture}
        \caption{Route durch den Graphen.}\label{fig:figure}
    \end{figure}

    In diesem Diagramm sind die Knoten als Kreise und die Verbindungen zwischen den Knoten als Linien dargestellt.
    Die rote gestrichelte Linie zeigt die Route durch den Graphen an.

    \subsection{Implementationsdetails}\label{subsec:implementationsdetails}
    Verwendete Datenstrukturen sind hauptsächlich Vektoren und Tupel, da sie eine einfache und effiziente Möglichkeit bieten,
    eine Liste von Koordinaten und eine Liste von Knoten (in Form von Paaren von Koordinaten) zu speichern.

    \[
        P = \left{ (x_1,y_1), (x_2,y_2), \ldots, (x_n,y_n) \right}
    \]

    Des Weiteren wird die Methode std::find verwendet, womit einfach überprüft werden kann,
    ob ein bestimmter Knoten bereits in der Route enthalten ist.
    Eine weitere verwendete Methode ist std::sort, wodurch sowohl eine hohe Effizienz garantiert ist,
    als auch die Lesbarkeit des Codes verbessert wird.

    \newpage
    \section{Beispiele}\label{sec:beispiele}

    \subsection{gerade.txt}\label{subsec:gerade.txt}

    \begin{lstlisting}[frame=single, title=Programmausgabe gerade.txt, breaklines=true,label={lst:lstlisting2}]
    Es konnte eine 300 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [0, 0]
    2. [100, 0] 180°
    3. [200, 0] 180°
    4. [300, 0]
    \end{lstlisting}

    Beim Aufruf für gerade.txt kommt es im Algorithmus nie zum Backtracking,
    womit eine Lösung in $O(n)$ gefunden wird.
    Das Winkelkriterium ist hierbei immer erfüllt, da jeder Winkel zwischen den Knoten 180° beträgt.
    Daran wird deutlich, dass eine Berechnung des Winkels über zwei Vektoren nicht sinnvoll ist,
    da dabei nicht zwischen dem Innenwinkel und dem Außenwinkel differenziert werden kann.
    Je nach Interpretation könnte der Winkel dann in diesem Fall 0° oder 180° betragen.

    \subsection{kreis.txt}\label{subsec:kreis.txt}


    \begin{figure}[H]
        \NewAdigraph{FigurFuenf}{
            1:4,1;
            2:3,1.5;
            3:2,2;
            4:1.5,3;
            5:1,4;
            6:1.5,5;
            7:2,6;
            8:3,6.5;
            9:4,7;
            10:5,6.5;
            11:6,6;
            12:6.5,5;
            13:7,4;
            14:6.5,3;
            15:6,2;
            16:5,1.5;
        }{
            1,2;1,3;1,4;1,5;1,6;1,7;1,8;1,9;1,10;1,11;1,12;1,13;1,14;1,15;1,16;
            2,3;2,4;2,5;2,6;2,7;2,8;2,9;2,10;2,11;2,12;2,13;2,14;2,15;2,16;
            3,4;3,5;3,6;3,7;3,8;3,9;3,10;3,11;3,12;3,13;3,14;3,15;3,16;
            4,5;4,6;4,7;4,8;4,9;4,10;4,11;4,12;4,13;4,14;4,15;4,16;
            5,6;5,7;5,8;5,9;5,10;5,11;5,12;5,13;5,14;5,15;5,16;
            6,7;6,8;6,9;6,10;6,11;6,12;6,13;6,14;6,15;6,16;
            7,8;7,9;7,10;7,11;7,12;7,13;7,14;7,15;7,16;
            8,9;8,10;8,11;8,12;8,13;8,14;8,15;8,16;
            9,10;9,11;9,12;9,13;9,14;9,15;9,16;
            10,11;10,12;10,13;10,14;10,15;10,16;
            11,12;11,13;11,14;11,15;11,16;
            12,13;12,14;12,15;12,16;
            13,14;13,15;13,16;
            14,15;14,16;
            15,16;
        }[-]
        \FigurFuenf{}
        \caption{Figur kreis.txt}
        \label{fig:Figure2}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe kreis.txt, breaklines=true,label={lst:lstlisting}]
    Es konnte eine 1677.05 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [400, 100]
    2. [300, 150] 180°
    3. [200, 200] 143.13°
    4. [150, 300] 180°
    5. [100, 400] 126.87°
    6. [150, 500] 180°
    7. [200, 600] 143.13°
    8. [300, 650] 180°
    9. [400, 700] 126.87°
    10. [500, 650] 180°
    11. [600, 600] 143.13°
    12. [650, 500] 180°
    13. [700, 400] 126.87°
    14. [650, 300] 180°
    15. [600, 200] 143.13°
    16. [500, 150]
    \end{lstlisting}

    Dieses Beispiel zeigt, wie die Nearest-Neighbour-Heuristik funktioniert.
    Die Lösung kann schnell ermittelt werden, da durch die Wahl des nächsten Nachbars eine Rekursion hier nie erforderlich ist.

    \subsection{viereck.txt}\label{subsec:viereck.txt}

    TODO: statt viereck ein einfaches beispiel nehemen wo einmal backttracking!
    backtracking pfad anhand von grapg darrstellen
    daigraph nehmen, weil sonst no time xd

    \begin{figure}[H]
        \NewAdigraph{FigurFuenf}{
            1:0,0;
            2:1,0;
            3:1,1;
            4:0,1;
        }{
            1,2;
            2,3;
            3,4;
            1,4;
            2,3;
            1,3;
            2,4;
        }[-]
        \FigurFuenf{}
        \caption{Figur viereck.txt}
        \label{fig:Figure3}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe viereck.txt, breaklines=true,label={lst:lstlisting3}]
    Es konnte eine 300 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [0, 0]
    2. [100, 0] 90°
    3. [100, 100] 90°
    4. [0, 100]
    \end{lstlisting}

    An diesem Beispiel wird deutlich, dass das Winkelkriterium Winkel von genau 90° akzeptiert.
    Auch hier ist kein Backtracking erforderlich um eine Lösung zu ermitteln.

    \subsection{nicht\_loesbar.txt}\label{subsec:nichtloesbar.txt}


    \begin{figure}[H]
        \centering
        \begin{tikzpicture}
            \node [set=my nodes, circle, draw] (a) at (0,3) {0,1};
            \node [set=my nodes, circle, draw] (b) at (0,1.5) {0,0.5};
            \node [set=my nodes, circle, draw] (c) at (3,3) {1,1};
            \node [set=my nodes, circle, draw] (d) at (6,0) {2,0};

            \graph { (a) -- (b) -- (a) -- (c) -- (a) -- (d) -- (a)};
            \graph { (b) -- (c) -- (b) -- (d) -- (b)};
            \graph { (c) -- (d) -- (c)};
        \end{tikzpicture}
        \caption{Figur nicht\_loesbar.txt}
        \label{fig:Figure4}
    \end{figure}

    \begin{lstlisting}[frame=single, title=Programmausgabe nicht\_loesbar.txt, breaklines=true,label={lst:lstlisting5}]
    Es konnte keine Flugstrecke durch alle Außenposten ermittelt werden.
    \end{lstlisting}

    Aufgrund der Berücksichtigung des Winkelkriteriums existiert keine Flugstrecke durch die gegebenen Außenposten.
    Um zu diesem Ergebnis zu gelangen traversiert der Algorithmus alle möglichen Pfade und kommt daher auf seine
    worst-case-Laufzeit von $O(n!)$.

    \subsection{wenigerkrumm1.txt}\label{subsec:wenigerkrumm1.txt}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm1.txt, breaklines=true,label={lst:lstlisting6}]
    Es konnte eine 853.246 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [200, 0]
    2. [210, 0] 180°
        [...]
    20. [390, 0] 180°
    21. [400, 0] 108.435°
    22. [405, 15] 143.13°
    23. [400, 30] 108.435°
    24. [390, 30] 180°
        [...]
    62. [10, 30] 180°
    63. [0, 30] 108.435°
    64. [-5, 15] 143.13°
    65. [0, 0] 108.435°
    66. [10, 0] 180°
        [...]
    83. [180, 0] 180°
    84. [190, 0]
    \end{lstlisting}

    Für die erste Eingabedatei kann eine Lösung in akzeptabler Zeit gefunden werden.
    Da durch die Nearest-Neighbour-Heuristik die geraden Abschnitte des Graphen sehr zielführend traversiert werden,
    kann eine Lösung ohne den Gebrauch von Backtracking gefunden werden, womit die Laufzeit für diese Eingabedatei bei $O(n)$ liegt.
    In den Auslassungen $[\dots]$ der Programmausgabe haben alle Übergänge einen Winkel von 180°.
    Die Anordnung der Außenposten kann annähernd als längliches Quadrat beschrieben werden.

    \subsection{wenigerkrumm2.txt}\label{subsec:wenigerkrumm2.txt}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm2.txt, breaklines=true,label={lst:lstlisting7}]
    Es konnte eine 2183.66 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [81.3473, 182.709]
    2. [117.557, 161.803] 168°
        [...]
    29. [0, 200] 168°
    30. [41.5823, 195.63] 114.343°
    31. [61.0105, 137.032] 138.343°
    32. [88.1678, 121.353] 168°
        [...]
    59. [0, 150] 168°
    60. [31.1868, 146.722]
    \end{lstlisting}

    Für die zweite Eingabedatei kann ebenfalls eine Lösung in akzeptabler Zeit gefunden werden,
    da auch hier die Nearest-Neighbour-Heuristik sehr zielführend ist.
    In den Auslassungen $[\dots]$ der Programmausgabe haben alle Übergänge einen Winkel von 168°.
    Die Anordnung der Außenposten stellt zwei Kreise dar, wobei ein kleinerer innerhalb eines größeren liegt.
    Der Übergang vom äußeren Graphen in den inneren Graphen kann an den abweichenden Winkeln 114.343° und 138.343° erkannt werden.

    \subsection{wenigerkrumm3.txt}\label{subsec:wenigerkrumm3.txt}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm3.txt, breaklines=true,label={lst:lstlisting8}]
    Es konnte eine 2102.94 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [169.282, 140]
        [...]
    6. [169.282, 60] 147.349°
    7. [159.452, 53.5304] 123.349°
    8. [159.452, 46.4696] 123.349°
    9. [169.282, 40] 147.349°
        [...]
    22. [52.9772, -64.7214] 150°
    23. [47.0228, -64.7214] 120.051°
    24. [40.5484, -53.5304] 174.051°
    25. [30.718, -40] 168°
    26. [23.9155, -24.7214] 168°
    27. [20.4382, -8.36228] 168°
    28. [20.4382, 8.36228] 164.131°
    29. [16.6329, 21.7482] 96.339°
    30. [23.9155, 24.7214] 172.073°
    31. [32.5389, 26.9164] 96.3573°
    32. [30.718, 40] 115.426°
    33. [40.5484, 46.4696] 123.349°
    34. [40.5484, 53.5304] 123.349°
    35. [30.718, 60] 115.426°
    36. [32.5389, 73.0836] 96.3573°
    37. [23.9155, 75.2786] 172.073°
    38. [16.6329, 78.2518] 96.339°
    39. [20.4382, 91.6377] 164.131°
        [...]
    43. [40.5484, 153.53] 174.051°
    44. [47.0228, 164.721] 120.051°
    45. [52.9772, 164.721] 120.051°
    46. [59.4516, 153.53] 174.051°
    47. [69.282, 140] 168°
    48. [76.0845, 124.721] 168°
    49. [79.5618, 108.362] 168°
    50. [79.5618, 91.6377] 164.131°
    51. [83.3671, 78.2518] 96.339°
    52. [76.0845, 75.2786] 172.073°
    53. [67.4611, 73.0836] 96.3573°
    54. [69.282, 60] 115.426°
    55. [59.4516, 53.5304] 123.349°
    56. [59.4516, 46.4696] 123.349°
    57. [69.282, 40] 115.426°
    58. [67.4611, 26.9164] 96.3573°
    59. [76.0845, 24.7214] 172.073°
    60. [83.3671, 21.7482] 96.339°
    61. [79.5618, 8.36228] 164.131°
        [...]
    65. [59.4516, -53.5304] 162°
    66. [32.5389, -73.0836] 162°
        [...]
    78. [-69.282, 40] 147.349°
    79. [-59.4516, 46.4696] 123.349°
    80. [-59.4516, 53.5304] 123.349°
    81. [-69.282, 60] 147.349°
        [...]
    93. [32.5389, 173.084] 162°
    94. [67.4611, 173.084] 162°
        [...]
    100. [159.452, 153.53] 113.503°
    101. [132.539, 73.0836] 90.4971°
    102. [116.633, 78.2518] 168°
    103. [100, 80] 156°
    104. [52.9772, 64.7214] 162°
    105. [47.0228, 64.7214] 90°
    106. [47.0228, 35.2786] 90°
    107. [52.9772, 35.2786] 162°
    108. [100, 20] 156°
        [...]
    111. [147.023, 35.2786] 120°
    112. [147.023, 64.7214] 95.9329°
        [...]
    116. [-47.0228, 64.7214] 120°
    117. [-47.0228, 35.2786] 120°
        [...]
    120. [0, 20]
    \end{lstlisting}

    Für die dritte Eingabedatei kann ebenfalls eine Lösung in akzeptabler Zeit gefunden werden,
    da auch hier wieder die Nearest-Neighbour-Heuristik sehr zielführend ist.
    In den Auslassungen $[\dots]$ der Programmausgabe haben alle Übergänge einen Winkel von 168°.
    Die Anordnung der Außenposten stellt vier Kreise dar, wobei sich alle vier Kreise überschneiden.

    \subsection{wenigerkrumm4.txt}\label{subsec:wenigerkrumm4.txt}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm4.txt, breaklines=true,label={lst:lstlisting9}]
    Es konnte eine 2383.56 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [20.2122, 156.013]
    2. [33.3797, 100.161] 160.586°
    3. [28.9137, 58.6999] 151.195°
    4. [51.0081, 5.7696] 149.699°
    5. [42.1378, -60.3199] 116.977°
    6. [-82.8641, -104.174] 106.026°
    7. [-98.7604, -81.7706] 176.676°
    8. [-137.318, -20.1469] 113.448°
    9. [-191.717, -28.3605] 179.89°
    10. [-221.15, -32.8625] 105.541°
    11. [-239.848, 8.6714] 154.98°
    12. [-239.414, 40.4271] 131.945°
    13. [-154.088, 115.023] 164.435°
    14. [-119.026, 168.454] 91.8053°
    15. [101.499, 33.4842] 170.242°
    16. [139.447, 0.233238] 97.6677°
    17. [94.7899, -67.0877] 145.005°
    18. [-129.104, -155.042] 96.1933°
    19. [-240.369, 57.4261] 127.717°
    20. [-219.149, 103.685] 150.887°
    21. [-107.989, 185.174] 105.549°
    22. [153.13, -20.3609] 108.462°
    23. [144.833, -43.4763] 98.9565°
    24. [-16.7231, -12.6895] 131.852°
    25. [-20.9712, -5.63711]
    \end{lstlisting}

    Auch für die vierte Eingabedatei kann eine Lösung in akzeptabler Zeit gefunden werden,
    da auch hier nur eine geringe Menge an Außenposten betrachtet werden muss.
    Obwohl die Anordnung der Außenposten keine bestimme Form darstellt,
    kommt es durch die Nearest-Neighbour-Heuristik dazu, dass der Algorithmus alle Außenposten in kreisförmiger Traversierung durchläuft.


    \subsection{wenigerkrumm5.txt}\label{subsec:wenigerkrumm5.txt}

    Für die Eingabedatei wenigerkrumm5.txt lässt sich mit dem Algorithmus keine Lösung in akzeptabler Zeit finden.
    Faktoren die für die hohe Laufzeit verantwortlich sein könnten sind die große Anzahl an gegebenen Außenposten,
    keine bestimme Form des Graphen, was zu einem schlechten Auswahlverfahren führt,
    als auch das die Außenposten in der Eingabe abwechselnd sehr weit oben und unten angeordnet sind,
    was zu vielen unnötigen Schritten führt.
    Aufgrund der hohen Laufzeit konnte keine Lösung gefunden werden.

    \subsection{wenigerkrumm6.txt}\label{subsec:wenigerkrumm6.txt}


    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm6.txt, breaklines=true,label={lst:lstlisting10}]
    Es konnte eine 4537.43 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [102.909, 60.1079]
    2. [100.007, 76.5793] 101.869°
    [...]
    79. [-288.744, -173.35] 107.052°
    80. [-293.833, -165.44]
    \end{lstlisting}

    Auch für die sechste Eingabedatei kann eine Lösung in akzeptabler Zeit gefunden werden,
    da es hier viele verschiedene Lösungen unabhängig vom Startpunkt gibt und daher nur selten rekursiv zurück gegangen werden muss.
    Aufgrund der Länge der Programmausgabe wurden hier einige Zeilen herausgenommen, auch da diese keinen weiteren inhaltlichen Mehrwert bieten.
    Die Anordnung der Außenposten stellt hier keine bestimme Form dar.

    \subsection{wenigerkrumm7.txt}\label{subsec:wenigerkrumm7.txt}

    \begin{lstlisting}[frame=single, title=Programmausgabe wenigerkrumm7.txt, breaklines=true,label={lst:lstlisting4}]
    Es konnte eine 6249.18 km lange Flugstrecke durch alle Außenposten ermittelt werden.
    1. [-47.2666, -66.984]
    2. [-46.4031, -13.7558] 174.189°
    [...]
    99. [296.912, 25.8116] 112.261°
    100. [256.476, -46.5914]
    \end{lstlisting}

    Für die siebte Eingabedatei kann eine Lösung in akzeptabler Zeit gefunden werden,
    da es hier viele verschiedene Lösungen unabhängig vom Startpunkt gibt und daher nur selten rekursiv zurück gegangen werden muss.
    Aufgrund der Länge der Programmausgabe wurden hier einige Zeilen herausgenommen, auch da diese keinen weiteren inhaltlichen Mehrwert bieten.
    Die Anordnung der Außenposten stellt hier keine bestimme Form dar.
    
    \newpage
    \section{Quellcode}
    \label{sec:quellcode}
    \label{LastPage}
    \lstset{language=C++,
        keywordstyle=\color{magenta},
        stringstyle=\color{red},
        commentstyle=\color{green},
    }
    \subsection{Implementation Obermethode}\label{subsec:implementation-obermethode}
    \begin{lstlisting}[frame=single,language=C++,title=Methode main,breaklines=true,label={lst:code_main}]
    /**
     * Liest die Eingabedateien ein und berechnet für jede Datei eine Lösung entsprechend der Aufgabenstellung.
     * Die Lösung wird anschließend in die entsprechende Ausgabedatei geschrieben.
     * Sollte es keine Lösung geben, wird dies ebenfalls in die Ausgabedatei geschrieben.
     * @return Exitcode
     */
    int main() {
        string input_dir = "../LennartProtte/Aufgabe1-Implementierung/Eingabedateien";
        string output_dir = "../LennartProtte/Aufgabe1-Implementierung/Ausgabedateien";

        //Durchläuft alle Dateien im Eingabeordner
        for (const std::filesystem::directory_entry &entry: filesystem::directory_iterator(input_dir)) {

            //Liest den Dateinamen aus
            string input_file = entry.path();
            string output_file = output_dir + "/" + entry.path().filename().string();

            //Öffnet die Eingabedatei
            ifstream fin(input_file);

            //Öffnet die Ausgabedatei
            ofstream fout(output_file);

            //Liest die Eingabedatei ein
            vector<pair<double, double> > coordinates;
            double x, y;
            while (fin >> x >> y) {
                coordinates.emplace_back(x, y);
            }

            //Berechnet die Lösung und schreibt das Ergebnis in die entsprechende Ausgabedatei
            vector<pair<double, double> > result;
            if (solve(result, coordinates)) {
                double distance = 0;
                for(int i = 0; i + 1 < result.size(); i++) {
                    distance += sqrt(pow((result[i].first - result[i+1].first), 2.0) + (pow((result[i].second - result[i+1].second), 2.0)));
                }
                fout << "Es konnte eine " << distance << " km lange Flugstrecke durch alle Außenposten ermittelt werden." << endl;
                for (int i = 0; i < result.size(); i++) {
                    fout << i + 1 << ". [" << result[i].first << ", " << result[i].second << "] ";
                    if (i != 0 && i != result.size() - 1) {
                        fout << cross_angle(result[i - 1], result[i], result[i + 1]) << "° " << endl;
                    } else {
                        fout << endl;
                    }
                }
            } else {
                fout << "Es konnte keine Flugstrecke durch alle Außenposten ermittelt werden." << endl;
            }
        }
        return 0;
    }
    \end{lstlisting}

    \newpage
    \subsection{Implementation Algorithmus}\label{subsec:implementation-algorithmus}
    \begin{lstlisting}[frame=single,language=C++,title=Methode solve,breaklines=true,label={lst:code_solve}]
    /**
     * Berechnet rekursiv mit Backtracking eine möglichst kurze Route durch den Graphen,
     * welche die Aufgabenkriterien erfüllt.
     * @param route die aktuelle Route
     * @param coordinates die Menge aller eingelesenen Koordinaten
     * @return true, wenn alle Knoten in der Lösungsmenge (route) enthalten sind, andernfalls false
     */
    bool solve(vector<pair<double, double> > &route, vector<pair<double, double> > &coordinates) {
        //Sortiere nach dem nächsten Knoten
        if (!route.empty()) {
            const auto &last = route.back();
            sort(coordinates.begin(), coordinates.end(),
                 [last](const auto &lhs, const auto &rhs) {
                     return sqrt(pow((last.first - lhs.first), 2.0) + (pow((last.second - lhs.second), 2.0)))
                            < sqrt(pow((last.first - rhs.first), 2.0) + (pow((last.second - rhs.second), 2.0)));
                 });
        }
        //Für jeden Knoten
        for (int i = 0; i < coordinates.size(); i++) {
            //Wenn dieser Knoten bereits in der Lösungsmenge existiert, überspringe diesen
            if (std::find(route.begin(), route.end(), coordinates[i]) != route.end()) {
                continue;
            }
            double angle = -1;
            if (route.size() >= 2) {
                angle = cross_angle(route[route.size() - 2], route.back(), coordinates[i]);
            }
            if (route.empty() ||
                (std::find(route.begin(), route.end(), coordinates[i]) == route.end() &&
                 (route.size() < 2 || angle >= 90))
                    ) {
                //Füge den Knoten hinzu
                route.push_back(coordinates[i]);
                //Wenn alle Knoten in der Lösungsmenge sind
                if (route.size() == coordinates.size()) {
                    return true;
                }
                //Wenn es eine Lösung mit der aktuellen Route gibt
                if (solve(route, coordinates)) {
                    return true;
                } else {
                    route.pop_back();
                }
            }
        }
    //Wenn es mit der aktuellen Route keine Lösung geben kann
        return false;
    }
    \end{lstlisting}

    \newpage
    \subsection{Implementation Hilfsmethode}\label{subsec:implementation-hilfsmethode}
    \begin{lstlisting}[frame=single,language=C++,title=Methode cross\_angle,breaklines=true,label={lst:code_crossAngle}]
    /**
     * Berechnet den Winkel in Grad zwischen den Vektoren von from_node nach over_node und over_node nach to_node
     * @param over_node der zweite Knoten
     * @param to_node der dritte Knoten (Zielknoten)
     * @param from_node der erste Knoten
     * @return false, wenn der Innenwinkel zwischen den Kanten kleiner als 90° beträgt, andernfalls true
     */
    double cross_angle(const pair<double, double> &from_node,
                       const pair<double, double> &over_node,
                       const pair<double, double> &to_node) {
        double a, b, c;
        a = sqrt(pow((from_node.first - to_node.first), 2.0) + (pow((from_node.second - to_node.second), 2.0)));
        b = sqrt(pow((from_node.first - over_node.first), 2.0) + (pow((from_node.second - over_node.second), 2.0)));
        c = sqrt(pow((over_node.first - to_node.first), 2.0) + (pow((over_node.second - to_node.second), 2.0)));
        double angle = acos((pow(a, 2.0) - pow(b, 2.0) - pow(c, 2.0)) / (-2 * b * c)) * 180 / M_PI;
        return angle;
    }
    \end{lstlisting}
\end{document}